exam.txt
блок 1
1. Понятие информации
2. Отличие информации от данных
3. Статическое и динамическое состояние информации
4. Характеристики основные виды информации.
5. Архитектура открытых систем.
6. Основные понятия архитектуры информационных сетей.
7. Класс информационных систем и сетей как открытые информационные системы.
8. Модели и структуры информационных систем.
9. Информационные ресурсы.
10. Теоретические основы современных информационных систем.
11. Базовая эталонная модель Международной организации стандартов.
12. Компоненты информационных систем.
13. Модель распределенной обработки информации.
14. Безопасность информации в системе.
15. Классификации информационных систем.
16. Структурированная, неструктурированная и слабо структурированная информация.
17. Классификация ИС по виду информации.
18. Предметные области ИС.
19. Архитектуры информационных систем.
20. Эталонная модель взаимодействия открытых систем.
21. Открытые системы и сети
+22. Уровни модели OSI
+23. Прикладной уровень OSI;
+24. Представительский уровень OSI;
+25. Сеансовый уровень OSI;
+26. Транспортный уровень OSI;
+27. Сетевой уровень OSI;
+28. Канальный уровень OSI;
+29. Физический уровень OSI;
30. Протоколы TCP/IP;
31. Протоколы IPX/SPX;
32. Основные протоколы прикладного уровня: 9P, BitTorrent, BOOTP, DNS, FTP, HTTP, NFS;
33. Основные протоколы прикладного уровня: POP, POP3, SMTP, X.400, X.500, SPDY;

блок 2
1. Текстовые интерфейсы информационных систем.
2. Смешанные интерфейсы информационных систем.
3. Графические интерфейсы информационных систем.
4. Многозвенные архитектуры информационных систем.
5. "Толстые" и "тонкие" клиенты.
6. Понятие спецификаций ИС.
7. Основные языки для описания спецификаций.
8. Основы языка UML.
9. UML-диаграмма классов.
10. UML-диаграмма компонентов.
11. UML-диаграмма композитной/составной структуры.
12. UML-диаграмма развёртывания.
13. UML-диаграмма объектов.
14. UML-диаграмма пакетов.
15. UML-диаграмма деятельности.
16. UML-диаграмма автомата.
17. UML-диаграмма вариантов использования.
18. Диаграммы коммуникации и последовательности.
19. UML-диаграмма обзора взаимодействия.
20. UML-диаграмма синхронизации.
21. Словари данных.
22. Поисковый образ документа. Метаданные.
23. Корпоративные информационные системы.
24. Программные и технические средства распределенных информационных систем.
25. Эталонные аппаратные платформы.
26. Типовые архитектурно-структурные решения.
27. Программное обеспечение информационных систем.
28. Методы оценки эффективности информационных систем.
29. Понятие базы данных.
30. Понятие СУБД. Архитектура СУБД.
31. Патологическая модель СУБД. Примеры
32. Иерархические модели СУБД. Примеры
33. Сетевые модели СУБД. Примеры
34. Реляционные модели СУБД. Примеры.
35. Объектно-ориентированные модели СУБД. Примеры

1. lesson1

1прикладной.md
# Прикладной уровень (Application Layer) модели OSI

## Основные функции
- Интерфейс между **приложениями** и сетью
- Реализация **сетевых сервисов** для пользователя
- Работа с **данными** (не с передачей)

## Ключевые задачи
1. **Предоставление сетевых сервисов**:
   - Веб (HTTP/HTTPS)
   - Почта (SMTP/POP3/IMAP)
   - Файлы (FTP/SFTP)
   - Удалённый доступ (SSH)

2. **Формирование запросов**:
   - Создание сообщений по протоколам
   - Обработка ответов

3. **Управление доступом**:
   - Аутентификация
   - Авторизация
   - Сессии

## Основные протоколы
| Протокол | Назначение               | Порт  |
|----------|--------------------------|-------|
| HTTP/HTTPS | Веб-страницы           | 80/443|
| FTP      | Передача файлов          | 20/21 |
| SMTP     | Отправка почты           | 25    |
| POP3/IMAP| Получение почты          | 110/143|
| DNS      | Преобразование доменов   | 53    |
| SSH      | Безопасный удалённый доступ | 22  |

## Пример работы
1. Пользователь вводит URL в браузере
2. Прикладной уровень:
   - Формирует HTTP-запрос
   - Устанавливает HTTPS-соединение
   - Обрабатывает ответ (HTML/JSON)
3. Браузер отображает результат

## Современные технологии
- **REST API** - взаимодействие сервисов
- **WebSockets** - постоянные соединения
- **OAuth** - авторизация между системами
- **gRPC** - высокопроизводительные API

## Отличие от других уровней
| Уровень | Решаемый вопрос |
|---------|-----------------|
| Сетевой | "Куда доставить?" |
| Транспортный | "Как доставить надежно?" |
| **Прикладной** | **"Что передавать?"** |

## Важность уровня
- Непосредственно обслуживает пользователя
- Определяет функциональность сетевых приложений
- Быстро развивается (новые протоколы и стандарты)

**Итог:** Прикладной уровень - это "лицо" сети для пользователей и приложений

2представительный.md
# Представительский уровень (Presentation Layer) модели OSI

## Основные функции
- **"Переводчик"** между приложениями
- Преобразование форматов данных
- Обеспечение совместимости

## Ключевые задачи
1. **Преобразование данных**:
   - Кодировки (ASCII ↔ Unicode)
   - Форматы чисел (big/little-endian)
   - Сериализация структур данных

2. **Сжатие данных**:
   - Без потерь: ZIP, GZIP
   - С потерями: JPEG, MP3

3. **Шифрование**:
   - TLS/SSL
   - Алгоритмы (AES, RSA)

## Примеры работы
- Конвертация UTF-8 ↔ UTF-16
- Сжатие изображений перед отправкой
- Шифрование HTTPS-трафика
- Преобразование XML ↔ JSON

## Технологии уровня
| Категория       | Примеры                  |
|-----------------|--------------------------|
| Кодировки       | ASCII, Unicode, UTF-8    |
| Форматы данных  | JSON, XML, ASN.1         |
| Сжатие          | ZIP, JPEG, MP3           |
| Шифрование      | SSL/TLS, AES             |

## Взаимодействие с другими уровнями
- Принимает данные от **сеансового** уровня
- Подготавливает данные для **прикладного** уровня
- Решает проблемы совместимости между системами

## Почему важен?
Без этого уровня:
- Текст отображался бы некорректно
- Числа интерпретировались бы неправильно
- Не было бы сжатия и шифрования

**Следующая тема:** Прикладной уровень (HTTP, FTP, SMTP)

3сеансовый.md
# Сеансовый уровень (Session Layer) модели OSI

## Основные функции
- **Организация диалога** между приложениями
- **Управление сессиями** (начало/поддержка/завершение)
- **Синхронизация** передачи данных
- **Контроль взаимодействия** между системами

## Ключевые задачи
1. **Управление сессиями**:
   - Установление соединения
   - Поддержка активности
   - Корректное завершение

2. **Синхронизация**:
   - Контрольные точки (checkpoints)
   - Восстановление после сбоев

3. **Режимы обмена**:
   - Simplex (односторонний)
   - Half-duplex (поочередный)
   - Full-duplex (двусторонний)

## Практические примеры
- **Удаленный доступ** (SSH/Telnet)
- **Онлайн-банкинг** (сессии операций)
- **Видеоконференции** (Zoom/Teams)
- **Файловые передачи** (FTP)

## Протоколы уровня
- **RPC** (Remote Procedure Call)
- **NetBIOS** (для Windows-сетей)
- **PPTP** (VPN-туннели)

## Сравнение с соседними уровнями
| Уровень | Функция |
|---------|---------|
| Транспортный | Доставка данных |
| **Сеансовый** | Управление диалогом |
| Прикладной | Работа с содержимым |

## Особенности реализации
- Часто объединен с прикладным уровнем
- В веб-технологиях реализован через:
  - Cookies
  - Токены
  - JWT

## Безопасность
- Контроль тайм-аутов
- Аутентификация сессий
- Защита от перехвата

**Следующая тема:** Представительский уровень (кодирование/сжатие данных)

4транспортный.md
# Транспортный уровень (Transport Layer) модели OSI

## Основные функции
- **Сквозная доставка** данных между приложениями
- **Управление соединением** и надежностью
- **Мультиплексирование** (разделение трафика по приложениям)

## Ключевые задачи
1. **Сегментация данных**:
   - Разбиение на части для передачи
   - Сборка в правильном порядке

2. **Контроль ошибок**:
   - Проверка целостности данных
   - Повторная передача при необходимости

3. **Управление потоком**:
   - Синхронизация скорости передачи
   - Предотвращение перегрузок

4. **Идентификация приложений**:
   - Использование портов (0-65535)
   - Примеры:
     - 80: HTTP
     - 443: HTTPS
     - 22: SSH

## Основные протоколы

### TCP (Transmission Control Protocol)
- **Надежный** (с подтверждением доставки)
- **С установкой соединения** (three-way handshake)
- **Упорядоченная** доставка
- Используется для:
  - Веб-страницы
  - Электронная почта
  - Передача файлов

### UDP (User Datagram Protocol)
- **Без установки соединения**
- **Минимальные задержки**
- **Нет гарантии доставки**
- Используется для:
  - Видеозвонки
  - Онлайн-игры
  - Потоковое видео

## Сравнение TCP и UDP
| Характеристика | TCP | UDP |
|---------------|-----|-----|
| Надежность | ✅ | ❌ |
| Порядок доставки | ✅ | ❌ |
| Контроль потока | ✅ | ❌ |
| Скорость | Медленнее | Быстрее |
| Накладные расходы | Высокие | Низкие |

## Примеры из практики
- **Веб-браузер** использует TCP (важна целостность страницы)
- **Zoom/Skype** использует UDP (важна минимальная задержка)

## Взаимодействие с другими уровнями
- Принимает **пакеты** от сетевого уровня
- Передает **сегменты/датаграммы** прикладному уровню
- Использует **порты** для идентификации сервисов

**Следующая тема:** Сеансовый уровень (управление сессиями)

5сетевой.md
# Сетевой уровень (Network Layer) модели OSI

## Основные функции
- **Маршрутизация** между разными сетями
- **Логическая адресация** (IP-адреса)
- **Фрагментация** пакетов
- **Контроль перегрузок**

## Ключевые концепции
### 1. IP-адресация
- Логические адреса (в отличие от MAC)
- Иерархическая структура:
  - IPv4: `192.168.1.1` (32 бита)
  - IPv6: `2001:0db8:85a3::8a2e:0370:7334` (128 бит)

### 2. Маршрутизация
- Определение пути через сети
- Таблицы маршрутизации
- Протоколы:
  - OSPF
  - RIP
  - BGP (для интернета)

### 3. Формат IP-пакета
| Поле          | Назначение                     |
|---------------|--------------------------------|
| IP отправителя| Адрес источника                |
| IP получателя | Адрес назначения               |
| TTL           | Время жизни (предотвращение зацикливания) |
| Протокол      | TCP/UDP/др.                    |
| Данные        | Полезная нагрузка              |

## Основные протоколы
- **IP** - доставка пакетов
- **ICMP** - диагностика и ошибки (`ping`)
- **ARP** - преобразование IP→MAC
- **IGMP** - управление multicast

## Сетевые устройства
### Маршрутизаторы (Router)
- Принимают решения о пересылке
- Работают с IP-адресами
- Поддерживают таблицы маршрутизации

## Пример передачи данных
1. Ваш компьютер:
   - Добавляет IP-заголовок
   - Указывает адрес назначения
2. Маршрутизаторы:
   - Анализируют IP
   - Передают по оптимальному пути

## Сравнение с канальным уровнем
| Канальный уровень       | Сетевой уровень        |
|-------------------------|------------------------|
| MAC-адреса             | IP-адреса              |
| Локальная доставка      | Глобальная маршрутизация|
| Коммутаторы            | Маршрутизаторы         |

## Важность сетевого уровня
- Основа работы интернета
- Обеспечивает связь между разными сетями
- Позволяет масштабировать сети

**Следующая тема:** Транспортный уровень (TCP/UDP)

6канальный.md
# Канальный уровень (Data Link Layer) модели OSI

## Основные функции
- Преобразует биты в **кадры (frames)**
- Обеспечивает надежную передачу между соседними узлами
- Управляет доступом к общей среде передачи

## Ключевые задачи
1. **Формирование кадров**:
   - Добавление заголовков/трейлеров
   - Четкие границы начала/конца сообщения

2. **Физическая адресация**:
   - Использование MAC-адресов (формат: `00:1A:2B:3C:4D:5E`)
   - Идентификация устройств в локальной сети

3. **Контроль ошибок**:
   - CRC (контрольная сумма)
   - Обнаружение поврежденных кадров

4. **Управление потоком**:
   - Синхронизация скорости передачи/приема

5. **Контроль доступа к среде (MAC)**:
   - CSMA/CD (Ethernet)
   - CSMA/CA (Wi-Fi)

## Формат Ethernet-кадра
| Поле                | Размер  | Назначение               |
|---------------------|---------|--------------------------|
| MAC назначения      | 6 байт  | Адрес получателя         |
| MAC источника       | 6 байт  | Адрес отправителя        |
| Тип/Длина           | 2 байт  | Идентификатор содержимого|
| Данные              | 46-1500 | Полезная нагрузка        |
| CRC                 | 4 байт  | Контрольная сумма        |

## Основные протоколы
- **Ethernet** - стандарт проводных LAN
- **PPP** - для point-to-point соединений
- **HDLC** - для WAN-сетей
- **Wi-Fi (802.11)** - беспроводные сети

## Сетевые устройства
- **Коммутаторы (Switch)** - фильтрация и пересылка по MAC-адресам
- **Сетевые адаптеры (NIC)** - обработка кадров на конечных устройствах
- **Мосты (Bridge)** - соединение сегментов сети

## Взаимодействие с другими уровнями
- Принимает **пакеты** от сетевого уровня
- Передает **биты** физическому уровню
- Процесс инкапсуляции/декапсуляции данных

## Практический пример
1. Ваш компьютер формирует кадр:
   - Добавляет MAC-адреса
   - Рассчитывает CRC
2. Коммутатор анализирует:
   - Проверяет MAC назначения
   - Пересылает только нужному порту

## Типичные проблемы
- Коллизии в Ethernet
- Ошибки CRC
- Перегрузка буферов коммутатора

## Отличие от физического уровня
| Физический уровень       | Канальный уровень        |
|--------------------------|--------------------------|
| Передает биты            | Работает с кадрами       |
| Не анализирует данные    | Понимает MAC-адресацию   |
| Хабы, репитеры           | Коммутаторы, мосты       |

Следующая тема: **Сетевой уровень (IP-адресация, маршрутизация)**

7физический.md
# Физический уровень модели OSI

## Основные понятия
- Самый нижний уровень модели OSI
- Работает с **битами** (0 и 1)
- Преобразует данные в физические сигналы:
  - Электрические (кабели)
  - Световые (оптоволокно)
  - Радиоволны (Wi-Fi)

## Ключевые функции
1. **Передача битов** через физическую среду
2. **Кодирование сигналов** (представление 0/1 в физической форме)
3. **Синхронизация** передачи
4. Управление **скоростью передачи** (bit rate)
5. Определение **физической топологии** сети

## Среды передачи
| Тип среды         | Примеры применения       |
|-------------------|--------------------------|
| Витая пара        | Ethernet (UTP/STP)       |
| Коаксиальный кабель| Старые сети, ТВ          |
| Оптоволокно       | Магистральные линии      |
| Радиоволны        | Wi-Fi, Bluetooth         |

## Методы кодирования
- **NRZ**: прямое соответствие бит и напряжения
- **Manchester**: изменение сигнала кодирует биты
- **Модуляции** (для беспроводных сетей):
  - AM (амплитудная)
  - FM (частотная)
  - PSK (фазовая)

## Типичные проблемы
- Электромагнитные помехи
- Затухание сигнала
- Физические повреждения кабеля
- Плохие контакты в разъемах

## Сетевое оборудование
- **Физического уровня**:
  - Кабели и разъемы
  - Хабы (концентраторы)
  - Репитеры
  - Модемы
- **Не относится** к этому уровню:
  - Коммутаторы (L2)
  - Маршрутизаторы (L3)

## Практический пример
✅ Индикатор на сетевом порту горит  
= Физическое соединение установлено  
❌ Индикатор не горит  
= Проблема на физическом уровне:
- Обрыв кабеля
- Неисправный разъем
- Отключенное питание

## Выводы
1. Базовый уровень для всей сетевой инфраструктуры
2. Не анализирует данные - только передает биты
3. Качество передачи влияет на работу всей сети
4. Первый уровень, где ищут проблемы при отсутствии связи

osi.md
# Модель OSI: концепция и применение

## Введение
- **Модель OSI** — эталонная модель взаимодействия открытых систем
- Абстрактная схема, а не конкретная технология
- Общий язык для совместимости сетевых устройств

## Зачем нужна модель OSI?
- Решает проблему совместимости оборудования разных производителей
- Стандартизирует процессы передачи данных
- "Договор" между участниками сетевого взаимодействия

## История создания
- Разработана ISO в 1970-80-х годах
- Принята в 1984 году
- Ответ на несовместимость сетевых решений разных вендоров

## Принцип уровневой модели
7 независимых уровней, где каждый:
1. Выполняет строго определённые функции
2. Взаимодействует только с соседними уровнями
3. Использует свои понятия и данные

**Аналогия**: процесс отправки письма (написание → упаковка → адресация → передача)

## Ключевые преимущества
- **Модульность**: можно менять один уровень без влияния на другие
- **Совместимость**: единый стандарт для разных производителей
- **Упрощение анализа**: чёткое разделение зон ответственности

## OSI vs TCP/IP
- На практике чаще используется TCP/IP (4 уровня вместо 7)
- Но OSI остаётся важной учебной моделью благодаря детализации

## Пример из жизни
Запрос к сайту проходит все 7 уровней:
1. Спуск по уровням на клиенте
2. Передача по сети
3. Подъём по уровням на сервере

## Профессиональное значение
- Язык общения специалистов
- Точно определяет область проблем ("ошибка на 4 уровне")

## Ключевые выводы
1. OSI — фундаментальная концепция сетевого взаимодействия
2. 7 уровней с чёткими функциями
3. Баланс изоляции и взаимодействия уровней
4. Теоретическая основа для образования и диагностики

1. lesson2

1pz.py
"""
считать с косоли свой возрас
выветси на консоль больше ли ваш возраст чем 18
определить тип переменной возраста, вывести на консоль
"""

age = int(input("Введи свой возраст: "))
print(age > 18)
print(type(age))

2pz.py
# 1. Запросите два числа
# 2. Запросите операцию (+, -, *, /)
# 3. Используя if/elif/else, выполните нужную операцию
# 4. Выведите результат и его тип
try:
    number1 = float(input("Введите первое число: "))
    number2 = float(input("Введите второе число: "))
except ValueError:
    print("Ошибка! Пожалуйста, вводите только числа.")
    exit(1)

operation = input("Введите операцию (+, -, *, /): ")

result = None

if operation == '+':
    result = number1 + number2
elif operation == '-':
    result = number1 - number2
elif operation == '*':
    result = number1 * number2
elif operation == '/':
    if number2 != 0:
        result = number1 / number2
    else:
        print("Ошибка! Деление на ноль нельзя.")
        exit()
else:
    print("Ошибка! Невозможная операция.")
    exit()

print(f"\nРезультат: {result}")
print(f"Тип результата: {type(result)}")

n1 = int(input("Введи первое число: "))
n2 = int(input("Введи второе число: "))
operation = input("Какую операцию хочешь выполнить? [+, -, *, /]: ")

if operation in ['+', '-', '*', '/']:
    if operation == "+":
        answer = n1 + n2
    elif operation == "-":
        answer = n1 - n2
    elif operation == "*":
        answer = n1 * n2
    elif operation == "/":
        if n2 == 0:
            answer = 0
        else:
            answer = n1 / n2
    print(answer)
    print(type(answer))
else:
    print(">> [ОШИБКА] Указана некорректная операция")

    num1 = int(input("Введите первое число:"))
num2 = int(input("Введите второе число:"))

op = input("Введите операцию (+, -, *, /): ")

result = None

if op == "+":
    result = num1 + num2
elif op == "-":
    result = num1 - num2
elif op == "*":
    result = num1 * num2
elif op == "/":
    if num2 != 0:
        result = num1 / num2
    else:
        print("Ошибка: деление на ноль!")
else:
    print("Ошибка: неизвестная операция!")

if result is not None:
    print(f"Резудьтат: {result}")
    print(f"Тип результата: {type(result)}")
else:
    print('Ошибка!')

3pz.py
# 1. Запросите два числа
# 2. Запросите операцию (+, -, *, /)
# 3. Используя if/elif/else, выполните нужную операцию
# 4. Выведите результат и его тип
# 5. Повторять все заново с использованием while
# 6. Завершить программу если пользователь введет 'exit'
def custom_input(is_operation: bool = None):
    if is_operation:
        operation = input("Введите операцию: ")
        if operation != "exit":
            return operation
    
    number = input("Введите число: ")
    if number != "exit":
        return int(number)
    raise Exception("exit")

while True:
    try:
        n1 = custom_input()
        n2 = custom_input()
        operation = custom_input(True)
        if operation == "+":
            print(n1 + n2)
        elif operation == "-":
            print(n1 - n2)
        elif operation == "*":
            print(n1 * n2)
        elif operation == '/':
            print(n1 / n2)
        else:
            raise Exception('invalid operation')

    except Exception as e:
        print(e)
        break

cycle_while.py
"""
while - цикл пока, с условием
break - полностью прерывает цикл
continue - пропускает итерацию
"""

count = 0
while True:
    if count == 10:
        break

    if count % 2 == 0:
        count += 1
        continue
        
    print(count)
    count += 1
else:
    print("цикл завершен")

exeptions.py
"""
try - попытка выполнить ошибкойный код
except - если в try возникла ошибка, то выполняется код в except
в except можно указать тип ошибки
else - если в try не возникла ошибки, то выполняется код в else
finally - выполняется всегда
exit(1) - выход из программы с кодом 1
"""
try:
    print()

except ZeroDivisionError:
    print("You can't divide by zero")

except Exception as e:
    print(e)

else:
    print('ошибок нет')

finally:
    print("выполняется всегда")

exit(1)

func_input.py
"""
функция с ()
print() - для вывода на консоль
type() - узнать тип данных
input() - для ввода с клавиатуры
int()
float()
str()
bool()
len()
in

all()
any()
вложенность доступна только с функциями, возвращающими значение
"""

# number = input()
# number = int(number)
# print(number + 5)
print(int(float("1.1")))
print(print())
"""
int
float
str
bool
list
set
dict
tuple
frozenset

int()
float()
str()
bool()

list()
set()
dict()
tuple()
frozenset()
"""

# bool

flag1 = True
flag2 = False
"""
>
<
>=
<=
!=
==
and логическое и *
or логическое или +
not отрицание
"""
number = 5
result = 2 < number < 78
print(result)

result = True and 7 < 54 and int('23') < 123 or 6 * 7 != 42 and not False
print(result)

func_print.py
from pprint import pprint

number = 5
print(1, 1, 1, 1, 1)
print(1, 1, 1, 1, 1, sep="-", end="")
print(1, 1, 1, 1, 1, sep=",", end="")

person = {
    'name': 'alice',
    'age': 24,
    'address': {
        'city': 'new york',
        'zip': '10101'
    },
    'phones': [
        88005553535,
        88005553536,
    ],
}

print(person)
pprint(person, indent=4)

ifelseelif.py
"""
if - если, с пробелом после if, с : в конце
если в условии образуется True, то выполняется первый блок кода внутри if
если в условии образуется False, то выполняется второй блок кода внутри else
else без условия, но с : в конце
else не обязателен
"""
age = int(input("Enter your age: "))

if age > 18:
    print("You are eligible to vote")
    print("You are eligible to vote")
    print("You are eligible to vote")
    print("You are eligible to vote")
else:
    print("You are not eligible to vote")

if True and 6 < 5 or not False:
    print("True")

flag1 = True

if flag1:
    print("True")

"""
Flase:
0
""
''
[]
()
{}
set()
frozenset()
None

True:
когда есть что-то
"""

if 0:
    if 0:
        print("True")
    else:
        print("False")
else:
    print("False")


mark = int(input("Enter your mark: "))

if mark >= 80:
    print("A")
elif mark >= 60:
    print("B")
elif mark >= 40:
    print("C")
else:
    print("D")

lists.py
list1 = []
print(type(list1))

operations = ['+', '-', '*', '/']

operations.py
"""
int целочисленный 1 234  45352314214
float 1.234 1.2345678901
str "123456789012345678901234567890"
str "text"
str '12-12-2012 Количество кликов: 21'
str ''
str ""
str ' '

bool True False

list
set
dict
tuple
frozenset
"""

print(1123)
str1 = '''
длинная 
строка
'''

amount_click = 12
float1 = 1.234
date = '12-12-2012'
register_date = '12-12-2012'
number = amount_click

print(type(date))
print(type(amount_click).__name__)
print(type(register_date).__name__)

flag = True
flag2 = False

"""
функция с ()
print() - для вывода на консоль
type() - узнать тип данных
"""

print()
print()
print()
print(2)
"""
\n - перенос строки
\t - таб
"""
print(number)

number = 12 + amount_click / 5 * 2 - 1

"""
+
-
*
/
** - возведение в степень
% - остаток от деления
// - целочисленное деление
"""

number = 12 % 5
print(number)

number = 14 // 5
print(number)

amount_click = amount_click + 1
print(amount_click)

"""
+=
-=
*=
/=
**=
%=
//=
"""

amount_click += 1
print(amount_click)

amount_click += 1
print(amount_click)

amount_click += 1
print(amount_click)

1. lesson3

cycle_for.py
print(0)
print(1)
print(2)
print(3)
print(4)

print()

count = 0
while count < 5:
    print(count)
    count += 1

print()

#для элементов               в  последовательности    :
#for <название_переменной>   in <последовательность>  :
for count in range(5):
    print(count)

str1 = "hello world"
print()

for letter in str1:
    print(letter)

print()

print(list(range(5)))

print()

for _ in range(5):
    print('hello world')

lists_and_range.py
"""
list - список, хранит разные типы данных
"""
list1 = []
print(list1)

list1 = [0, 1, 2, 3, 4]
print(list1)
"""
индексация начинается с 0
"""
list1 = [3, 1.1, "asd", True, None, [1, 2]]
#[3, 1.1, "asd", True, None, [1, 2]]
# 0   1    2     3      4      5
print(list1)

for e in list1:
    print(e)

list1 = list(range(10))
print(list1)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(list1[0])
print(list1[1])
print(list1[5])
print(list1[8])

print()

str1 = "asd"
# asd
# 012
print(str1[0])
print(str1[1])
print(str1[2])

print()
"""
внутри [i] - индекс, если 1 элемент
[i:j:k] - срез списка с начиная i по j не включительно с шагом k
i - начало/start
j - конец/stop
k - шаг/step
"""
list1 = list(range(10))
print(list1)
print(list1[2:5])
print('первая половина:', list1[5:])
print('вторая половина:', list1[:5])

print()

print(list(range(2, 20)))
print(list(range(6, 10)))

print()

# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(list1[2:9:2])
# [2, 4, 6, 8]

print(list(range(60, 8061, 250)))

pz4.py
"""
создать список с чисел от 100 до 1000000 с шагом 5000
вывести на экран
"""

pz5.py
"""
Вычислите средний балл для каждого студента
Найдите индекс студента с самым высоким средним баллом
Найдите индексы всех студентов, у которых есть хотя бы одна оценка 2
"""
names = ["Анна", "Борис", "Виктория", "Григорий", "Дарья"]
grades_list = [
    [4, 5, 4, 3, 5],
    [3, 4, 3, 5, 4],
    [5, 5, 5, 4, 5],
    [2, 3, 2, 4, 3],
    [4, 4, 5, 4, 4]
]

averages = [0, 0, 0, 0, 0]
i = 0
for grades in grades_list:
    total = 0
    count = 0
    for grade in grades:
        total += grade
        count += 1
    averages[i] = total / count
    i += 1

best_index = 0
i = 1
while i < 5:
    if averages[i] > averages[best_index]:
        best_index = i
    i += 1

students_with_2 = []
i = 0
for grades in grades_list:
    has_two = False
    for grade in grades:
        if grade == 2:
            has_two = True
            break
    if has_two:
        students_with_2 = students_with_2 + [i]
    i += 1

print("Средние баллы:", averages)
print("Индекс лучшего студента:", best_index)
print("Индексы студентов с оценкой 2:", students_with_2)

1. lesson4

1.py
list1 = []
list1

listGuide.py
"""
методы и функции list
"""
zero_list = []

list1 = [1, 2, 3]
list1.append(1)  # добавление в конец
# list1 = [1, 2, 3, 1]

#print(list1.append(1)) - не сработает

list1.extend([5, 5])  # увеличение списка, list1 += [5, 5]
# list1 = [1, 2, 3, 1, 5, 5]

list1.insert(1, 9)  #вставка на позицию | insert(index, value)
# list1 = [1, 9, 2, 3, 1, 5, 5]

list1.remove(1)  # удаление первого вхождения
# list1 = [9, 2, 3, 1, 5, 5]

list1.pop(0)  # удаление по индексу
# list1 = [2, 3, 1, 5, 5]

number = list1.index(1)  # находит индекс первого вхождения
# number = 2 - тк 2 индекс

number = list1.count(5)  # количество вхождений
# number = 2 - тк 2 пятерки

list1.sort()  # сортировка
sorted(list1)  # сортировка
# list1 = [1, 2, 3, 5, 5]

list1.reverse()  # переворачивает
list1 = list1[::-1]  # переворачивает
# list1 = [5, 5, 3, 2, 1]

list1.clear()  # очищает
print(list1)

print([i for i in range(100)])
print([i**2 for i in range(10)])
print([i for i in range(100) if i % 2 == 0])
print([i for i in range(100) if i % 2 == 0 if i % 3 == 0])
print([None if x % 2 == 0 else x for x in range(100)])
print([i+j for i in range(10) for j in range(10)])
# кубы чисел кратных 14

print([i**3 for i in range(100) if i % 14 == 0])
def c14(limit):
    for i in range(14, limit, 14):
        yield i**3
g = c14(14)
print(list(g))
def gen(n):
    for i in range(1, n + 1):
        yield i
def fibgen():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b
g = list(gen(5))
print(g)
g = fibgen()
for _ in range(10):
    print(next(g))

def fact(n):
    if n == 0 or n == 1:
        return 1
    return n * fact(n - 1)
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    elif n < 0:
        raise Exception
    return fib(n - 1) + fib(n - 2)

print(fib(6))
print(fact(3))

def fast_power(base, exponent):
    if exponent == 0:
        return 1
    elif exponent % 2 == 0:
        half_power = fast_power(base, exponent // 2)
        return half_power * half_power
    else:
        return base * fast_power(base, exponent - 1)

print(fast_power(10, 5))

1. lesson5

imports.py
import math
import random
import random as rd
from random import randint as rint
import time
from math import *
from math import pi as p, sqrt as s

#pip install numpy
import numpy as np

import pandas as pd

# print(rd.randint(1, 5))
print(rint(1, 5))

print(pi)

main.py
print("рассчет стоимости покупки")

price = int(input("введите цену товара: "))
count = int(input("введите количество товара: "))

total = price * count

if total > 1000:
    total = total * 0.9 # скидка 10%

print(f'Стоимость покупки: {total} рублей')

monolit.py
"""
input
логика
вывод
"""

1.2. modules

input_func.py
def input_data():
    return input("введите данные: ")

main.py
from input_func import *
from process_func import *
from output_func import *

if __name__ == '__main__':
    data = input_data()
    data = process_data(data)
    output_data(data=data)

output_func.py
def output_data(data: str) -> None:
    print(data)

process_func.py
def process_data(data: str) -> str:
    return data.swapcase()

1. lesson6

mermaid.md
## uml class diagramm

```mermaid
classDiagram
    %% Основные классы
    class User {
        +str name
        +str email
        +placeOrder(): Order
    }
    class Order {
        +int orderId
        +datetime orderDate
        +addProduct(product: Product): void
    }
    class Product {
        +int productId
        +str name
        +float price
    }
    class ShoppingCart {
        +list[Product] items
        +addToCart(product: Product): void
    }

    %% Отношения между классами
    User "1" --> "many" Order : places
    User "1" --* "1" ShoppingCart : owns
    ShoppingCart "1" --o "many" Product : contains
    Order "1" --o "many" Product : includes
```

pz1.txt
с заголовком и пояснением что делает такая диаграмма. UML-диаграмма классов.

10. UML-диаграмма компонентов.
11. UML-диаграмма композитной/составной структуры.
12. UML-диаграмма развёртывания.
13. UML-диаграмма объектов.
14. UML-диаграмма пакетов.
15. UML-диаграмма деятельности.
16. UML-диаграмма автомата.
17. UML-диаграмма вариантов использования.
18. Диаграммы коммуникации и последовательности.
19. UML-диаграмма обзора взаимодействия.
20. UML-диаграмма синхронизации.
21. Монолитная архитектура
22. Модульная архитектура

1. lesson7

myDeque.py
from collections import deque

stack = deque()

stack.append(1)
stack.append(2)
stack.append(3)
print(stack)
print(stack.pop())
print(stack.pop())
print(stack.pop())

if not stack:
    print("Стек пуст")

"""
append(x)     добавляет элемент x в конец стека
pop()         удаляет и возвращает последний элемент стека
if not stack  проверка, пуст ли стек
stack[-1]     Peek Просмотр верхнего элемента
clear()       очистка, не всегда
"""

"""
Дана строка, содержащая скобки различных типов: (), [], {}. 
Необходимо проверить, является ли скобочная последовательность корректной. 
Корректная последовательность означает, 
что каждой открывающей скобке соответствует закрывающая скобка того же типа, 
и скобки правильно вложены друг в друга.
"""

str1 = "()[]{}" # True
str2 = "([{}])" # True
str3 = "(]" # False
str4 = "([)]" # False

def is_valid_brackets(s):
    stack = []
    brackets_map = {')': '(', ']': '[', '}': '{'}
    for char in s:
        if char in brackets_map.values():
            stack.append(char)
        elif char in brackets_map:
            if not stack or stack.pop() != brackets_map[char]:
                return False
    return not stack

print(is_valid_brackets(str1))
print(is_valid_brackets(str2))
print(is_valid_brackets(str3))
print(is_valid_brackets(str4))

queue = deque()

queue.append(1)
queue.append(2)
queue.append(3)
print(queue)

print(queue.popleft())
print(queue.popleft())
print(queue.popleft())
print(queue)

if not queue:
    print("Очередь пуста")

"""
реализовать class структуру данных очередь
добавление элемента в очередь enqueue
удаление элемента из очереди dequeue
получение максимального элемента в очереди get_max max
получение минимального элемента в очереди get_min min

использовать deque 
"""


class SimpleMinMaxQueue:
    def __init__(self):
        self.queue = deque()

    def enqueue(self, x):
        self.queue.append(x)

    def dequeue(self):
        if not self.queue:
            return None
        return self.queue.popleft()

    def get_max(self):
        if not self.queue:
            return None
        return max(self.queue)

    def get_min(self):
        if not self.queue:
            return None
        return min(self.queue)

smq = SimpleMinMaxQueue()
smq.enqueue(3)
smq.enqueue(1)
smq.enqueue(5)
print(smq.get_max())
print(smq.get_min())
print()
smq.dequeue()
print(smq.get_max())
print(smq.get_min())
print()
smq.dequeue()
print(smq.get_max())
print(smq.get_min())
print()
smq.dequeue()
print(smq.get_max())
print(smq.get_min())
"""
добавление
append(x)
appendleft(x)

удаление
pop()
popleft()

методы
clear()  полностью очистить
extend(iterable) — добавляет все элементы из итерируемого объекта в конец deque
extendleft(iterable) — добавляет все элементы из итерируемого объекта в начало deque (элементы добавляются в обратном порядке)
rotate(n) — циклически сдвигает элементы deque на n шагов. Если n положительное, сдвиг происходит вправо, если отрицательное — влево
count(x)  возвращает количество элементов, равных x
remove(x)  удаляет первый найденный элемент, равный x

свойство
maxlen  максимальный размер deque (если задан). Если при добавлении элементов размер превышает maxlen, элементы с противоположного конца автоматически удаляются
"""
d = deque([1, 2, 3])
d.extend([4, 5, 6])  # Добавляем элементы в конец
print(d)  # deque([1, 2, 3, 4, 5, 6])

d = deque([4, 5, 6])
d.extendleft([1, 2, 3])  # Добавляем элементы в начало
print(d)  # deque([3, 2, 1, 4, 5, 6])

d = deque([1, 2, 3, 4, 5])
d.rotate(2)  # Сдвигаем вправо на 2 шага
print(d)  # deque([4, 5, 1, 2, 3])

d.rotate(-2)  # Сдвигаем влево на 2 шага
print(d)  # deque([1, 2, 3, 4, 5])

d = deque([1, 2, 3])
d.clear()  # Очищаем deque
print(d)  # deque([])

d = deque([1, 2, 2, 3, 2, 4])
print(d.count(2))  # 3 (элемент 2 встречается 3 раза)

d = deque([1, 2, 3, 2, 4])
d.remove(2)  # Удаляем первый элемент 2
print(d)  # deque([1, 3, 2, 4])

# Создаем deque с максимальным размером 3
d = deque([1, 2, 3], maxlen=3)
print(d)  # deque([1, 2, 3], maxlen=3)

# Добавляем новый элемент
d.append(4)  # Элемент 1 удаляется, так как maxlen=3
print(d)  # deque([2, 3, 4], maxlen=3)

# Добавляем несколько элементов
d.extend([5, 6])  # Элементы 2 и 3 удаляются
print(d)  # deque([4, 5, 6], maxlen=3)


"""
реализовать скользящее окно для массива чисел. 
для каждого окна размера k найти максимальный элемент."""

nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
"""
[1, 3, -1]  3
[3, -1, -3]  3
[-1, -3, 5]  5
[-3, 5, 3]  5
[5, 3, 6]  6
[3, 6, 7]  7

[3, 3, 5, 5, 6, 7]"""

from collections import deque

def max_in_sliding_window(nums, k):
    if not nums or k == 0:
        return []

    result = []
    d = deque()

    for i, num in enumerate(nums):
        while d and d[0] < i - k + 1:
            d.popleft()

        while d and nums[d[-1]] < num:
            d.pop()

        d.append(i)

        if i >= k - 1:
            result.append(nums[d[0]])

    return result

nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(max_in_sliding_window(nums, k))

