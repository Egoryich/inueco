exam.txt
блок 1
1. Определение алгоритма. Свойства алгоритма. Формы записи алгоритмов. Примеры.
2. Запись алгоритмов блок-схемами. Основные элементы блок-схем.
3. Алгоритмы с ветвлением. Пример алгоритма.
4. Алгоритм цикла с предусловием. Пример алгоритма.
5. Алгоритм цикла с постусловием. Пример алгоритма.
6. Алгоритм цикла с управляющей переменной. Пример алгоритма.
7. Основные типы данных
8. Целый и вещественный типы данных. Операции с переменными этого типа.
9. Логический тип данных. Символьный тип данных. Операции с переменными этого типа.
10. Поколения языков программирования и их характеристики.
11. Алфавит, лексика языка программирования. Пример.
12. Синтаксис и семантика программирования. Пример.
13. Составные части исходной программы.
14. Что такое система программирования? Назовите классы систем программирования.
15. Объясните суть процессов трансляции и компиляции.
16. Что такое библиотеки подпрограмм и для чего их используют?
17. Файл. Типы файлов.
18. Общие принципы разработки ПО.
19. Частотный принцип разработки ПО и принцип модульности.
20. Принцип функциональной избирательности при разработке ПО и принцип генерируемости.
21. Принцип функциональной избыточности при разработке ПО и принцип «по умолчанию».
22. Общесистемные принципы разработки ПО.
23. Как использовать операторы инкремента и декремента для изменения значений переменных целого типа?
24. Как использовать операторы сравнения и работать с символьными данными в языке программирования?
25. Какие ключевые слова и символы принадлежат лексике конкретного языка программирования?
26. Каким образом организовать код программы для улучшения его читаемости и структурированности?
27. Как выбрать подходящую систему программирования для конкретной задачи?
28. Как можно использовать стандартные и пользовательские библиотеки для оптимизации разработки программ?
29. Как обрабатывать события, связанные с работой с файлами в визуальных компонентах?
30. Какие основные типы файлов существуют, и чем они отличаются друг от друга?
31. Какие применения можно выделить для различных типов файлов в контексте программирования?
32. Какие общие принципы следует учитывать при разработке программного обеспечения?
33. Что представляет собой частотный принцип разработки ПО?
34. Как принцип модульности помогает улучшить структуру и поддерживаемость программного кода?
35. Как использовать стандартные потоки для обмена данными между программой и операционной системой?

блок 2
1. Классификация ЯП.
2. Понятие транслятора, компилятора
3. Машинные языки, эволюция программирования.
4. Структурный подход: предпосылки и особенности, история успеха
5. Принципы проектирования: снизу-вверх и сверху-вниз.
6. Этапы жизненного цикла программного обеспечения (ПО), основные модели.
7. Основные управляющие конструкции. Блок-схемы.
8. Понятие о трансляторе и трансляции.
9. Понятие о компиляции и компиляторе.
10. Машинный язык, объектные файлы, линковка.
11. Исполняемые файлы. Формат выполняемых файлов.
12. Тип данных и их форматы.
13. Приведение примитивных типов. Типы значений и ссылочные типы.
14. Лексемы и пробельные символы.
15. Объявления и типы данных.
16. Понятие о переменной.
17. Синтаксис объявления и инициализации.
18. Составное присвоение.
19. Области видимости.
20. Время жизни переменных.
21. Работа с консольными приложениями. Создание нового проекта.
22. Добавление к проекту файлов с исходным кодом.
23. Компиляция, компоновка и выполнение проекта.
24. Конфигурация проекта.
25. Операторы ввода-вывода.
26. Поток. Манипуляторы и форматирование ввода-вывода.
27. Выражения.
28. Виды выражений.
29. Порядок (приоритеты) вычислений.
30. Типы операций.
31. Условный оператор.
32. Полная и неполная формы условного оператора.
33. Тернарная операция.
34. Оператор выбора.
35. Циклические операции.
36. Особенности использования циклов разных конструкций.
37. Организация массивов в программе.
38. Синтаксис описания массивов.
39. Операции над массивами.
40. Указатели и массивы.
41. Адресная арифметика.
42. Строки и литералы.
43. Указатели и строки.
44. Основные операции над строками.
45. Процедуры и функции.
46. Передача параметров при организации процедур/функций.
47. Рекурсия.
48. Глобальные и локальные переменные. Области видимости переменных.
49. Структуры. Алгоритмы работы.
50. Объединения. Алгоритмы работы.
51. Перечисление. Алгоритмы работы.
52. Открытие и закрытие файла.
53. Чтение и запись текстовых файлов.
54. Файлы произвольного доступа.
55. Работа с файлами при использовании визуальных компонент.
56. Стандартные потоки в операционных системах.
57. Ввод со стандартного потока ввода.
58. Ввод средствами языка python.
59. Описание опций формата функций input и print.
60. Как создать новый консольный проект?
61. Как добавить новый файл с исходным кодом к существующему проекту?
62. Как выполнить процесс компиляции и запустить консольное приложение?
63. Как использовать различные конфигурации проекта для разработки и отладки?
64. Как изменить конфигурацию проекта (например, целевую платформу или версию языка)?
65. Как работать с потоками ввода-вывода в языке программирования?
66. Какие виды выражений можно использовать в языке программирования?
67. Какие правила приоритета операторов следует учитывать при написании сложных выражений?
68. Какие возможности предоставляет условный оператор в языке программирования?
69. В каких случаях применение тернарной операции предпочтительно?
70. Как использовать различные типы массивов (одномерные, двумерные) в программе?
71. Как использовать указатели и адресную арифметику для работы с массивами?
72. Как объявлять и инициализировать строки в языке программирования?
73. Как использовать литералы строк для упрощения работы с текстовой информацией?
74. Как использовать указатели для манипуляции строками?
75. В чем преимущества использования указателей при работе с символьными строками?
76. Какие методы передачи параметров поддерживаются в языке программирования?
77. В каких случаях целесообразно использовать передачу параметров по значению или по ссылке?
78. Как определить и использовать рекурсивные функции?
79. Как избегать бесконечной рекурсии и оптимизировать рекурсивные алгоритмы?
80. Как объявить и использовать структуры в языке программирования?
81. Какие алгоритмы обработки данных в структурах являются наиболее эффективными?
82. Как открывать и закрывать файлы в языке программирования?
83. Как обработать ошибки, возникающие при открытии и закрытии файлов?
84. Как работать с файлами произвольного доступа?
85. Как использовать указатели для навигации по данным в файле?

блок 3
1. Эволюция парадигм программирования.
2. Предпосылки появления ООП.
3. Определение объекта и класса, различия.
4. Понятие класса, объекта.
5. Структура описания класса.
6. Создание и инициализация экземпляра класса (объекта).
7. Поля и методы.
8. Конструкторы и деструкторы классов.
9. Объявление объектов (создание экземпляров) класса.
10. Принцип инкапсуляции.
11. Обеспечение безопасности данных.
12. Классификация и использование модификаторов доступа.
13. Акцессоры для доступа к закрытым полям.
14. Принцип наследования.
15. Основные достоинства и преимущества использования. Синтаксис объявления наследования.
16. Виды наследования в ООП.
17. Виды и примеры наследования классов в python.
18. Запечатанные классы.
19. Абстрактные классы.
20. Иерархия наследования.
21. Определение наследования.
22. Базовые и производные классы.
23. Конструкторы производных классов.
24. Базовые функции класса.
25. Иерархия классов. Наследование и графика.
26. Общее и частное наследование.
27. Уровни наследования.
28. Множественное наследование.
29. Неопределенность в множественном наследование.
30. Включение: классы в классах.
31. Роль наследования при разработке программ.
32. Обобщение и специализация.
33. Принцип полиморфизма. Основные достоинства и преимущества использования. Синтаксис
34. Скрытие и переопределение. Виртуальные методы. Виды полиморфизма в python.
35. Интерфейсы. Примеры решения практических задач с использованием технологии объектно-ориентированного программирования.
36. Понятие COM-объекта
37. Шаблоны функций.
38. Шаблоны классов.
39. Исключения. Обработка ошибок пользователей.
40. Контейнеры. Алгоритмы.
41. Итераторы. Специальные итераторы.
42. Последовательные и ассоциативные контейнеры.
43. Хранение пользовательских объектов. Функциональные объекты.
44. Как объявляется наследование в синтаксисе языка программирования?
45. В чем отличия между одними видами наследования и другими?
46. Какие преимущества и ограничения существуют при использовании запечатанных классов?
47. Как создать и использовать абстрактные классы в языке программирования?
48. Как выбрать подходящую структуру иерархии для конкретной задачи?
49. Как организовать иерархию наследования классов?
50. Как определить наследование и отличить базовый класс от производного?
51. Какие аспекты следует учитывать при определении иерархии наследования?
52. В чем заключается общее и частное наследование в ООП?
53. Какие сценарии предпочтительны для каждого из видов наследования?
54. Как реализуется множественное наследование в объектно-ориентированных языках программирования?
55. Какие преимущества и ограничения существуют при использовании множественного наследования?
56. В чем заключается включение (композиция) классов в объектно-ориентированном программировании?
57. Как осуществляется реализация полиморфизма в языке программирования?
58. Как создать и использовать виртуальные методы в python?
59. Какие виды полиморфизма реализуются в языке python?
60. Что представляет собой COM-объект и как организовано взаимодействие с ним?
61. Как создавать и использовать шаблоны классов?

1. lesson1

dict.py
zero_dict = {}

translation = {
    "ананас": "pineapple",
    "яблоко": "apple",
}

dict1 = { "1": 123, "2": 234, }

print(translation)
print(zero_dict)
print(dict1)

print(translation["ананас"])
print(translation["яблоко"])

print(translation.get("яблоко2", "яблоко2 нет в словаре"))

dict2.py
"""
.keys() - список ключей
.values() - значений
.items() - пары ключ - значение
.get(key, default) возвр значение по ключу и default если ключ отсутствует
.pop(key, default) удаление и возвр значения
.popitem() удаляет и возвр последнюю добавл пару
.clear()
.copy()
del удаление
"""

dict1 = {'name': 'alice', 'city': 'new york'}
print(type(dict1))

set1 = set()

zero_dict = {}
zero_dict['age'] = 30
zero_dict['name'] = 'bob'
print(zero_dict)

zero_dict['name'] = 'bob2'
print(zero_dict)

dict1 = dict(name='bob', age=30)

# ----------------------------------------------------------------
num = 42
hash_value = hash(num)
print(hash_value)

# my_list = [1, 2, 3, 4]
# hash_value = hash(my_list)
# print(hash_value)

str1 = '123'
hash_value = hash(str1)
print(hash_value)

my_list = [1, 2, 3, 4]
hash_value = hash(tuple(my_list))
print(hash_value)

# my_set = {1, 2, 3}
# hash_value = hash(my_set)
# print(hash_value)

my_set = {1, 2, 3}
hash_value = hash(frozenset(my_set))
print(hash_value)
# ----------------------------------------------------------------

"""
.keys() - список ключей
.values() - значений
.items() - пары ключ - значение
.get(key, default) возвр значение по ключу и default если ключ отсутствует
.pop(key, default) удаление и возвр значения
.popitem() удаляет и возвр последнюю добавл пару
.clear()
.copy()
del удаление
"""
person = {
    'name': 'alice',
    'age': 24,
    'address': {
        'city': 'new york',
        'zip': '10101'
    },
    'phones': [
        88005553535,
        88005553536,
    ],
}

print(person.keys())
print(person.values())
deleted_value = person.pop('address', None)
print(deleted_value)
print(person.get('address', "нет адреса"))

for key, value in zero_dict.items():
    print(key, value, sep=': ')

print(zero_dict['age'])
print(zero_dict.get('name', None))
zero_dict['age'] = 31
del zero_dict['name']
print(zero_dict)

a = {
    "name": "alice",
    "age": 243,
    'address': {
        "city": "new york",
        "zip": '10101'
    }
}
basketball_players = {}

def add_player(name, height):
    if name in basketball_players:
        print(f"{name} уже есть")
    else:
        basketball_players[name] = height
        print(f'{name} добавлен')

def remove_player(name):
    if name in basketball_players:
        del basketball_players[name]
    else:
        print(f'{name} нет')

def find_player(name):
    if name in basketball_players:
        print(f'{name} {basketball_players[name]}')
    else:
        print(f'{name} нет')

def update_player(name, new_height):
    if name in basketball_players:
        basketball_players[name] = new_height
        print(f'{name} {basketball_players[name]}')
    else:
        print(f'{name} нет')

pz1.py
"""
1. Структура данных
Основной словарь: {key: {nested_key: nested_value}}
Трехуровневая вложенность: dict → dict → dict
Ключи верхнего уровня: Уникальные идентификаторы (числа)

2. Базовые операции
А. Итерация по словарю
python
# Получение всех ключей
keys = list(data.keys())
i = 0
while i < len(keys):
    current_key = keys[i]
    current_value = data[current_key]
    i += 1
Б. Доступ к вложенным данным
python
# Доступ ко второму уровню
value = data[key]["property_name"]

# Доступ к третьему уровню  
nested_value = data[key]["nested_dict"]["nested_property"]
В. Добавление и изменение данных
python
# Добавление нового элемента
data[new_key] = {"prop1": value1, "prop2": value2}

# Изменение существующего
data[key]["existing_prop"] = new_value

# Добавление во вложенный словарь
data[key]["nested_dict"]["new_prop"] = value
3. Конкретные алгоритмы обработки
А. Расчет среднего значения списка
python
values = list(nested_dict.values())
total = 0
j = 0
while j < len(values):
    total += values[j]
    j += 1
average = total / len(values) if values else 0
Б. Поиск максимального значения в словаре
python
keys = list(scores.keys())
best_key = keys[0]
best_score = scores[best_key]

i = 1
while i < len(keys):
    current_key = keys[i]
    current_score = scores[current_key]
    if current_score > best_score:
        best_key = current_key
        best_score = current_score
    i += 1
В. Группировка данных по категориям
python
groups = {}
keys = list(data.keys())
i = 0
while i < len(keys):
    key = keys[i]
    category = data[key]["category"]
    
    if category not in groups:
        groups[category] = {"count": 0, "total": 0, "items": []}
    
    groups[category]["count"] += 1
    groups[category]["total"] += data[key]["value"]
    groups[category]["items"].append(data[key]["name"])
    i += 1
Г. Проверка на уникальность хешей
python
hashes_list = list(hashes_dict.values())
unique_hashes = []
j = 0
while j < len(hashes_list):
    current_hash = hashes_list[j]
    found = False
    k = 0
    while k < len(unique_hashes):
        if current_hash == unique_hashes[k]:
            found = True
            break
        k += 1
    if not found:
        unique_hashes.append(current_hash)
    j += 1

is_unique = len(unique_hashes) == len(hashes_dict)
Д. Фильтрация по условию
python
results = []
keys = list(data.keys())
i = 0
while i < len(keys):
    key = keys[i]
    if data[key]["property"] == target_value:
        results.append(data[key]["name"])
    i += 1
4. Управление выводом
python
# Разделители блоков
print("-" * 50)

# Форматированный вывод вложенных данных
props = list(item.keys())
j = 0
while j < len(props):
    prop = props[j]
    value = item[prop]
    print(f"  {prop}: {value}")
    j += 1

5. Особенности реализации
Ручное управление индексами: Использование счетчиков i, j, k в циклах while
Явное преобразование в список: list(dict.keys()) и list(dict.values())
Проверка на пустоту: if len(list) > 0 перед операциями
Построчная печать: Последовательный вывод данных через multiple print()

6. Альтернативные конструкции
Вместо: while с ручным индексом
Можно использовать: for key in data: для прямого обхода ключей
Вместо: Ручной подсчет суммы в цикле
Можно использовать: sum(list(values))
Вместо: Ручная проверка уникальности хешей
Можно использовать: len(set(hashes_dict.values())) == len(hashes_dict)
"""
students = {
    101: {
        "name": "Иван Иванов",
        "age": 20,
        "grades": {"math": 4, "physics": 5, "programming": 5},
        "group": "ИТ-101"
    },
    102: {
        "name": "Мария Петрова", 
        "age": 19,
        "grades": {"math": 5, "physics": 4, "programming": 4},
        "group": "ИТ-101"
    },
    103: {
        "name": "Алексей Сидоров",
        "age": 21, 
        "grades": {"math": 3, "physics": 3, "programming": 4},
        "group": "ИТ-102"
    }
}

"""
1
Выведите на экран информацию о всех студентах в читаемом формате. Для каждого студента отобразите:
ID студента
Имя
Возраст
Группу
Все оценки по предметам
"""
print("-" * 50)
student_ids = list(students.keys())
i = 0
while i < len(student_ids):
    student_id = student_ids[i]
    student_data = students[student_id]
    
    print("ID:", student_id)
    print("Имя:", student_data["name"])
    print("Возраст:", student_data["age"])
    print("Группа:", student_data["group"])
    print("Оценки:")
    
    subjects = list(student_data["grades"].keys())
    j = 0
    while j < len(subjects):
        subject = subjects[j]
        grade = student_data["grades"][subject]
        print(" ", subject, ":", grade)
        j = j + 1
    
    print("----------------------------------")
    i = i + 1
"""
2
Добавьте в словарь нового студента с ID 104:
Имя: "Екатерина Волкова"
Возраст: 20
Оценки: math=5, physics=5, programming=5
Группа: "ИТ-102"
Выведите сообщение о добавлении.
"""
print("-" * 50)
new_student_id = 104
new_student = {
    "name": "Екатерина Волкова",
    "age": 20,
    "grades": {"math": 5, "physics": 5, "programming": 5},
    "group": "ИТ-102"
}

students[new_student_id] = new_student
print("Добавлен новый студент:", new_student["name"])
"""
3
Для каждого студента рассчитайте и выведите средний балл по всем предметам. 
Сохраните результаты в отдельный словарь average_grades.
"""
print("-" * 50)
average_grades = {}
student_ids = list(students.keys())
i = 0
while i < len(student_ids):
    student_id = student_ids[i]
    student_data = students[student_id]
    
    grades_list = list(student_data["grades"].values())
    total = 0
    j = 0
    while j < len(grades_list):
        total = total + grades_list[j]
        j = j + 1
    
    if len(grades_list) > 0:
        avg_grade = total / len(grades_list)
    else:
        avg_grade = 0
    
    average_grades[student_id] = avg_grade
    print(student_data["name"], ":", avg_grade)
    i = i + 1
"""
4
Найдите студента с наивысшим средним баллом. Выведите его имя, средний балл и группу.
"""
print("-" * 50)
student_ids = list(average_grades.keys())
best_id = student_ids[0]
best_grade = average_grades[best_id]

i = 1
while i < len(student_ids):
    current_id = student_ids[i]
    current_grade = average_grades[current_id]
    if current_grade > best_grade:
        best_id = current_id
        best_grade = current_grade
    i = i + 1

best_student = students[best_id]
print("Лучший студент:", best_student["name"])
print("Средний балл:", best_grade)
print("Группа:", best_student["group"])
"""
5
Соберите статистику по группам:
Количество студентов в каждой группе
Средний балл группы
Список студентов каждой группы
Выведите статистику для групп "ИТ-101" и "ИТ-102".
"""
print("-" * 50)
group_stats = {}
student_ids = list(students.keys())
i = 0
while i < len(student_ids):
    student_id = student_ids[i]
    student_data = students[student_id]
    group = student_data["group"]
    
    if group not in group_stats:
        group_stats[group] = {"count": 0, "total_grade": 0, "students": []}
    
    group_stats[group]["count"] = group_stats[group]["count"] + 1
    group_stats[group]["total_grade"] = group_stats[group]["total_grade"] + average_grades[student_id]
    group_stats[group]["students"].append(student_data["name"])
    i = i + 1

target_groups = ["ИТ-101", "ИТ-102"]
k = 0
while k < len(target_groups):
    group = target_groups[k]
    if group in group_stats:
        stats = group_stats[group]
        
        print("Группа", group + ":")
        print(" Количество студентов:", stats["count"])
        
        if stats["count"] > 0:
            avg_group_grade = stats["total_grade"] / stats["count"]
        else:
            avg_group_grade = 0
        
        print(" Средний балл группы:", avg_group_grade)
        print(" Студенты:", end=" ")
        
        m = 0
        while m < len(stats["students"]):
            if m > 0:
                print(",", end=" ")
            print(stats["students"][m], end="")
            m = m + 1
        print()
        print()
    else:
        print("Группа", group + ": не найдена")
        print()
    k = k + 1
"""
6
Для каждого студента вычислите хеш его имени с помощью функции hash(). 
Проверьте, есть ли коллизии хешей (одинаковые хеши для разных имен).
"""
print("-" * 50)
name_hashes = {}
student_ids = list(students.keys())
i = 0
while i < len(student_ids):
    student_id = student_ids[i]
    student_data = students[student_id]
    name_hash = hash(student_data["name"])
    name_hashes[student_id] = name_hash
    print(student_data["name"], ":", name_hash)
    i = i + 1

print("")
print("Проверка коллизий хешей:")
hashes_list = list(name_hashes.values())
unique_hashes = []
j = 0
while j < len(hashes_list):
    current_hash = hashes_list[j]
    found = False
    k = 0
    while k < len(unique_hashes):
        if current_hash == unique_hashes[k]:
            found = True
            break
        k = k + 1
    if not found:
        unique_hashes.append(current_hash)
    j = j + 1

if len(unique_hashes) == len(students):
    print("Коллизий хешей не обнаружено!")
else:
    print("Обнаружены коллизии хешей!")
"""
7
Найдите и выведите:
Всех студентов с оценкой 5 по программированию
Всех студентов старше 20 лет
"""
print("-" * 50)
student_ids = list(students.keys())
i = 0
while i < len(student_ids):
    student_id = student_ids[i]
    student_data = students[student_id]
    if "programming" in student_data["grades"] and student_data["grades"]["programming"] == 5:
        print("-", student_data["name"], "(Группа:", student_data["group"] + ")")
    i = i + 1

print("")
print("Студенты старше 20 лет:")
i = 0
while i < len(student_ids):
    student_id = student_ids[i]
    student_data = students[student_id]
    if student_data["age"] > 20:
        print("-", student_data["name"], "(Возраст:", student_data["age"], ")")
    i = i + 1
"""
8
Добавьте всем студентам оценку по предмету "english":
ID 101: 4
ID 102: 5
ID 103: 3
ID 104: 5
Выведите обновленные данные для студента ID 101.
"""
print("-" * 50)
student_ids = list(students.keys())
i = 0
while i < len(student_ids):
    student_id = student_ids[i]
    if student_id == 101:
        students[student_id]["grades"]["english"] = 4
    elif student_id == 102:
        students[student_id]["grades"]["english"] = 5
    elif student_id == 103:
        students[student_id]["grades"]["english"] = 3
    elif student_id == 104:
        students[student_id]["grades"]["english"] = 5
    i = i + 1

print("Добавлены оценки по английскому языку!")

print("")
print("Обновленные данные студента ID 101:")
print("ID: 101")
print("Имя:", students[101]["name"])
print("Возраст:", students[101]["age"])
print("Группа:", students[101]["group"])
print("Оценки:")
subjects = list(students[101]["grades"].keys())
j = 0
while j < len(subjects):
    subject = subjects[j]
    grade = students[101]["grades"][subject]
    print(" ", subject, ":", grade)
    j = j + 1

1. lesson2

pz1.py
"""
Разработать программу "Научный калькулятор", состоящую из трех модулей. 
Каждый модуль должен выполнять строго определенные функции и взаимодействовать 
с другими модулями через четко определенные интерфейсы.

Требования:
Реализовать модульную архитектуру с четким разделением ответственности
Применять функции модуля math для математических операций
Обеспечить обработку ошибок и проверку входных данных
Соблюдать принцип единственной ответственности для каждого модуля

2. Спецификация модулей
Модуль 1: calculator.py (Математическое ядро)
Задачи:

Реализовать базовые арифметические операции:
Сложение, вычитание, умножение, деление
Проверка деления на ноль с выбрасыванием исключения
Реализовать научные операции с использованием math:
Возведение в степень
Квадратный корень (с проверкой отрицательного входного значения)
Натуральный логарифм и логарифм по произвольному основанию
Тригонометрические функции (синус, косинус, тангенс)
Факториал (с проверкой неотрицательного целого числа)

Требования к функциям:
Все функции должны проверять корректность входных параметров
При ошибках - выбрасывать исключения с понятными сообщениями
Каждая функция должна возвращать результат вычислений

Модуль 2: utils.py (Вспомогательные утилиты)
Задачи:
Реализовать утилиты преобразования единиц измерения:
Функция преобразования градусов в радианы
Функция преобразования радианов в градусы

Реализовать утилиты форматирования вывода:
Функция форматирования математических операций для красивого вывода
Функция создания строки с результатом вычисления

Реализовать утилиты для работы с данными:
Функция проверки числа на целость
Функция проверки числа на положительность

Требования:
Все функции должны возвращать новые данные, не изменяя входные параметры
Функции должны быть независимыми и самодостаточными

Модуль 3: main.py (Основная программа)
Задачи:
Организовать демонстрацию работы всех модулей:
Импортировать необходимые функции из других модулей
Продемонстрировать работу базовых и научных операций

Реализовать тестовые сценарии:
Демонстрация работы с отдельными математическими операциями
Примеры корректных вычислений и обработки ошибок
Примеры работы с тригонометрическими функциями

Организовать структурированный вывод:
Отдельные секции для разных типов операций
Четкое отображение входных данных и результатов
Вывод сообщений об ошибках при некорректных операциях
Показать взаимодействие между модулями:
Использование функций из calculator.py для вычислений
Применение утилит из utils.py для преобразования и форматирования

3. Примеры тестовых сценариев для main.py
Арифметические операции с разными числами
Вычисление квадратных корней из положительных чисел и обработка попытки извлечения корня из отрицательного числа
Работа с тригонометрическими функциями (вычисление синуса, косинуса для углов в градусах и радианах)
Вычисление факториалов для разных чисел
Примеры с обработкой ошибок (деление на ноль, логарифм от отрицательного числа)
"""

1. lesson3

pz1.py
#1 O(n)
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1


#2 O(n)
def sum_array(arr):
    total = 0
    for num in arr:
        total += num
    return total


#3
def find_max(arr):
    if not arr:
        return None
    max_val = arr[0]
    for num in arr:
        if num > max_val:
            max_val = num
    return max_val


#4
def print_array(arr):
    for element in arr:
        print(element)


#5
def count_even_numbers(arr):
    count = 0
    for num in arr:
        if num % 2 == 0:
            count += 1
    return count

    
#6
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]


#7
def print_all_pairs(arr):
    for i in range(len(arr)):
        for j in range(len(arr)):
            print(f"({arr[i]}, {arr[j]})")


#8 O(n^2)
def has_duplicates(arr):
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] == arr[j]:
                return True
    return False


#9
def transpose_matrix(matrix):
    rows = len(matrix)
    cols = len(matrix[0])
    result = [[0 for _ in range(rows)] for _ in range(cols)]
    
    for i in range(rows):
        for j in range(cols):
            result[j][i] = matrix[i][j]
    return result


#10
def multiply_matrices(a, b):
    rows_a = len(a)
    cols_a = len(a[0])
    cols_b = len(b[0])
    result = [[0 for _ in range(cols_b)] for _ in range(rows_a)]
    
    for i in range(rows_a):
        for j in range(cols_b):
            for k in range(cols_a):
                result[i][j] += a[i][k] * b[k][j]
    return result


#11 O(1)
def get_element(arr, index):
    return arr[index]


#12
def append_to_list(lst, element):
    lst.append(element)


#13
def is_first_element_zero(arr):
    if arr[0] == 0:
        return True
    return False


#14
def get_length(arr):
    return len(arr)


#15
def swap(a, b):
    temp = a
    a = b
    b = temp
    return a, b


#16
def bubble_sort_optimized(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break


#17
def bubble_first_pass(arr):
    n = len(arr)
    for j in range(0, n - 1):
        if arr[j] > arr[j + 1]:
            arr[j], arr[j + 1] = arr[j + 1], arr[j]


#18
def search_sorted_matrix(matrix, target):
    if not matrix:
        return False
        
    row = 0
    col = len(matrix[0]) - 1
    
    while row < len(matrix) and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] > target:
            col -= 1
        else:
            row += 1
    return False


#19
def sum_matrix(matrix):
    total = 0
    for row in matrix:
        for element in row:
            total += element
    return total

    
#20
def find_common_element(arr1, arr2):
    for elem1 in arr1:
        for elem2 in arr2:
            if elem1 == elem2:
                return elem1
    return None


"""
Алгоритм 1: Линейный поиск
Последовательно проверяет каждый элемент массива до нахождения искомого значения.
Сложность: O(n) - в худшем случае необходимо проверить все n элементов массива.

Алгоритм 2: Сумма элементов массива
Вычисляет общую сумму всех числовых элементов в массиве.
Сложность: O(n) - требуется один последовательный проход по всем n элементам для их сложения.

Алгоритм 3: Поиск максимума в массиве
Находит наибольшее значение в массиве путем последовательного сравнения элементов.
Сложность: O(n) - необходимо сравнить между собой все n элементов массива.

Алгоритм 4: Печать всех элементов массива
Выводит каждый элемент массива на экран в отдельной строке.
Сложность: O(n) - выполняется ровно n операций вывода.

Алгоритм 5: Подсчет четных чисел
Считает количество четных чисел в массиве путем проверки каждого элемента.
Сложность: O(n) - каждая из n итераций включает проверку условия четности.

Алгоритм 6: Пузырьковая сортировка
Сортирует массив путем многократного прохода и попарного сравнения соседних элементов.
Сложность: O(n²) - два вложенных цикла дают n*(n-1)/2 сравнений в худшем случае.

Алгоритм 7: Вывод всех пар элементов
Генерирует и выводит все возможные пары элементов массива.
Сложность: O(n²) - для каждого из n элементов создается n пар, всего n² комбинаций.

Алгоритм 8: Поиск дубликатов в массиве
Проверяет наличие повторяющихся элементов путем попарного сравнения всех элементов.
Сложность: O(n²) - количество сравнений растет пропорционально n*(n-1)/2.

Алгоритм 9: Транспонирование матрицы
Создает новую матрицу, где строки становятся столбцами, а столбцы - строками.
Сложность: O(n*m) - обрабатывается каждый элемент матрицы размером n на m.

Алгоритм 10: Умножение матриц
Выполняет умножение двух матриц по правилу "строка на столбец".
Сложность: O(n³) - для квадратных матриц n×n требуется три вложенных цикла по n итераций.

Алгоритм 11: Доступ к элементу массива по индексу
Возвращает значение элемента массива по заданному индексу.
Сложность: O(1) - доступ по индексу выполняется за постоянное время.

Алгоритм 12: Вставка элемента в конец списка
Добавляет новый элемент в конец списка.
Сложность: O(1) - амортизированная сложность добавления в конец списка Python.

Алгоритм 13: Проверка первого элемента массива
Проверяет, равен ли первый элемент массива нулю.
Сложность: O(1) - выполняется единственная операция сравнения.

Алгоритм 14: Получение длины массива
Возвращает количество элементов в массиве.
Сложность: O(1) - длина хранится как свойство объекта и доступна мгновенно.

Алгоритм 15: Обмен значений двух переменных
Меняет местами значения двух переменных с использованием временной переменной.
Сложность: O(1) - выполняется фиксированное количество операций присваивания.

Алгоритм 16: Оптимизированная пузырьковая сортировка
Улучшенная версия пузырьковой сортировки с досрочным завершением при отсутствии обменов.
Сложность: O(n²) - в худшем случае сохраняется квадратичная сложность.

Алгоритм 17: Частичная пузырьковая сортировка
Выполняет только один проход пузырьковой сортировки, частично упорядочивая массив.
Сложность: O(n) - один проход по n-1 парам элементов.

Алгоритм 18: Поиск в отсортированной матрице
Ищет элемент в матрице, отсортированной по строкам и столбцам, начиная из правого верхнего угла.
Сложность: O(n + m) - в худшем случае выполняется n+m шагов по строкам и столбцам.

Алгоритм 19: Подсчет суммы элементов в матрице
Вычисляет сумму всех элементов двумерной матрицы.
Сложность: O(n × m) - необходимо обработать каждый элемент матрицы размером n на m.

Алгоритм 20: Поиск общего элемента в двух массивах
Находит первый общий элемент в двух массивах путем полного перебора всех пар.
Сложность: O(n × m) - каждый элемент первого массива сравнивается с каждым элементом второго.
"""

sorting.py
"""
бинарный поиск
"""

"""
по способу организации

внутренняя сортировка - в оперативке
внешняя - для больших данных, с записью во временные файлы
"""

"""
по устойчивости (стабильности)

стабильная сортировка- сохраняет порядок одинаковых элементов
нестабильная - может измениться
"""

"""
по принципу работы

обменные алгоритмы - пузырьковая - if else
выборочные - выбором - выбирается минимальный элемент
вставочные - вставками - новый элемент вставляется в отсортированную часть списка
разделяй и властвуй - быстрая, слиянием - рекурсия, части сортируются
"""

"""
.sort() - сортирует список на месте - изменяет его
sorted() - возвращает новый"""

"""numbers = [5, 4, 2, 6, 7, 8, 3, 5, 6, 9]
numbers.sort()
print(numbers)

numbers = [5, 4, 2, 6, 7, 8, 3, 5, 6, 9]
sorted_numbers = sorted(numbers)
print(sorted_numbers)

words = ['123', '1234', '12', '12334']
words.sort(key=len)
print(words)

students = [('иван', 20), ("анна", 18), ("петр", 22)]
students.sort(key=lambda x: x[1])
print(students)

numbers = [5, 4, 2, 6, 7, 8, 3, 5, 6, 9]
numbers.sort(reverse=True)
print(numbers)

numbers = [5, 4, 2, 6, 7, 8, 3, 5, 6, 9]
sorted_numbers = sorted(numbers, reverse=True)
print(sorted_numbers)"""
"""
O(n)
n - размер входных данных (сколько элементов)
"""

"""
простые O(n^2)
пузырьковая, вставками, выбором
"""

"""
продвинутые O(n log n)
слиянием быстрая 
"""

"""
гибридные
timsort: вставками + слиянием
"""

"""
пузырьковая (bubble sort)
"""

"""
1 проход

[5, 3, 8, 4, 2] 5 3 8 4 2
5 > 3
3 5
[3, 5, 8, 4, 2]
5 < 8
[3, 5, 8, 4, 2]
8 > 4
4 8
[3, 5, 4, 8, 2]
8 > 2
2 8
[3, 5, 4, 2, 8]
"""

def bubble_sort_bad(arr):
    for i in range(len(arr)):
        for j in range(len(arr)):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

#[3, 2, 4, 5, 8]
#[2, 3, 4, 5, 8]
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        swapped = False
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break

#выбором (selection sort)

"""
min из неотсортированной части массива
меняем этот минимальный e с первым e неотсортированной части
повторяем
"""

"""
1 проход

[5, 3, 8, 4, 2]
2 <-> 5
[2, 3, 8, 4, 5]

2 проход

[2, 3, 8, 4, 5]
3 <-> 5
[2, 3, 8, 4, 5]

3 проход

[2, 3, 8, 4, 5]
4 <-> 8
[2, 3, 4, 8, 5]

"""

def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        min_index = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index] ,arr[i]

"""numbers = [5, 3, 8, 4, 2]
selection_sort(numbers)
print(numbers)"""

def selection_sort(arr):
    n = len(arr)
    left, right = 0, n - 1
    while left < right:
        min_index = left
        max_index = right

        for i in range(left, right + 1):
            if arr[i] < arr[min_index]:
                min_index = i
            if arr[i] > arr[min_index]:
                max_index = i

        arr[left], arr[min_index] = arr[min_index], arr[left]

        if max_index == left:
            max_index = min_index

        arr[right], arr[max_index] = arr[max_index], arr[right]

        left += 1
        right -= 1
"""
[]
[4, 2, 5, 1]
min 1
[1, 2, 5, 4]
[1]

[1]
[1, 2, 5, 4]
min 2
[1, 2, 5, 4]
[1, 2]

[1, 2]
[1, 2, 5, 4]
min 4
[1, 2, 4, 5]

"""





"""
левая уже отсортирована
правая нет

[5, 2, 4, 6, 1, 3]
2 < 5
[2, 5, 4, 6, 1, 3]
"""

def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1

        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1

        arr[j + 1] = key



"""
[4, 3, 2, 1]
3 4
3 
[3 4 2 1]
2 < 4 
4
[3 4 4 1]
2 < 3
[3 3 4 1]
[2 3 4 1]

[2 3 4 4]
[2 3 3 4]
[2 2 3 4]
[1 2 3 4]
"""

"""
1: выбираем шаг
2: сортируем с шагом
3: уменьшаем шаг
4: дойдя до 1 = обычная вставками

[5, 2, 9, 1, 5, 6]
первые элементы:
i = 0 3 6
[5, 1]
вторые элементы:
i = 1, 4
[2, 5]
третьи элементы:
i = 2, 5
[9, 6]

[1, 2, 6, 5, 5, 9]

хиббарда
"""

def shell_sort(arr):
    n = len(arr)
    gap = n // 2

    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i

            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp

        gap //= 2

# массивы из numpy (они там на C)
"""
массив из 1 элемента - отсортирован
разделяем массив на две части
рекурсивно сортируем каждую из этих частей
сливаем в один массив

[1, 4, 6]
[2, 3, 5]

[8, 4, 5, 7, 1, 3, 6, 2]
[8, 4, 5, 7] [1, 3, 6, 2]
[8, 4] [5, 7] [1, 3] [6, 2]
[8] [4] [5] [7] [1] [3] [6] [2]
[8] [4] -> [4, 8]
[5] [7] -> [5, 7]
[4, 5, 7, 8]
[1, 2, 3, 6]

особенности/важно
стабилен
неинтерактивность
рекурсивность 
"""

def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

        result.extend(left[i:])
        result.extend(right[j:])

        return result

"""

max-heap: каждый родитель больше или равен своим детям
min-heap: каждый родитель меньше или равен своим детям
"""
"""
heap - вид бинарного дерева, частично упорядочена
max-heap (макси-куча): каждый родитель больше или равен своим детям (потомкам)
min-heap (мини-куча): каждый родитель меньше или равен своим детям (потомкам)

max-heap (макси-куча): на вершине максимальный элемент. Получаем минимальный элемент на O(1)
min-heap (мини-куча): на вершине наименьший элемент. Получаем минимальный элемент на O(1)

алгоритм Дейкстры 
heap sort
реализация приоритетной очереди
медиана потока данных
планировщики задач
системы обработки событий
сжатия данных

import heapq - минимальная куча на базе списка
"""
import heapq

numbers = [5, 3, 8, 1, 2]
heapq.heapify(numbers)  # на месте в мин кучу. numbers[0] - минимальный. Порядок остальных не гарантирован
print(numbers)

heapq.heappush(numbers, 0)  # добавляет item в heap и сохраняет ее свойства
print(numbers)

min_element = heapq.heappop(numbers)  # удаляет и возвращает наименьший элемент из кучи
print(min_element)
print(numbers)

#heapq.heappushpop(heap, item) добавляет item, возвращает наименьший элемент

numbers = [5, 3, 8, 1, 2]
#n самых больших или маленьких элементов
print(heapq.nlargest(2, numbers))
print(heapq.nsmallest(3, numbers))


#приоритетная очередь
tasks = []
heapq.heappush(tasks, (2, 'писать отчет'))
heapq.heappush(tasks, (1, 'проверить почту'))
heapq.heappush(tasks, (3, 'созвон с коллегами'))

while tasks:
    task = heapq.heappop(tasks)
    print(f'выполняется задача {task}')

# макси куча

numbers = [5, 3, 8, 1, 2]
max_heap = [-x for x in numbers]
heapq.heapify(max_heap)

max_value = -heapq.heappop(max_heap)
print(max_value)

heap = [1, 3, 5, 7, 9, 8]
"""
        1
      /   \
     3     5
    / \     \
   7   9     8
"""
"""
бинарная куча, каждый узел имеет не более двух детей

"""
"""

для любого элемента с i - индекс
левый потомок на позиции 2*i + 1
правый потомок на позиции 2*i + 2
родитель потомок на позиции (i - 1) // 2

        10              <- индекс 0
      /    \
     9      8           <- индексы 1 и 2
    / \    / \
   7   6  5   4         <- индексы 3,4,5,6
                                arr[3] = 7
                                
arr =[10, 9, 8, 7, 6, 5, 4]
""""""
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)"""

"""
+
экономия памяти
быстрота доступа
простота реализации
универсальность
"""

def build_heap(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

"""
[3, 9, 2, 1, 4, 5]
i = 2 (последний родитель): 2, 5 - переставлять не надо
i = 1: 9, 1, 4 (9 остается на месте)
i = 0: 3, 9, 2 (меняем 3 и 9)
[9, 3, 2, 1, 4, 5]
"""
"""
для любого элемента с i - индекс
левый потомок на позиции 2*i + 1
правый потомок на позиции 2*i + 2
родитель потомок на позиции (i - 1) // 2
i   родитель    левый   правый
0   -   1   2
1   0   3   4
2   0   5   6
3   1   7   8
4   1   9   10

"""
"""
heap sort (по возрастанию) (in-place)
1 массив в максимальную кучу
2 максимальный элемент в корне arr[0]
3 меняем местами с последним элементом в массиве и исключаем из обработки
4 heapify 
5 повторяем

1 построение кучи - проходим по массиву снизу вверх и восстанавливаем кучу от каждого элемента
2 сортировка 
2.1 берем максимум
2.2 меняем с последним неотсортированным элементом
2.3 уменьшаем границу кучи
2.4 heapify

+
O(nlogn)
не требует доп памяти
для больших объемов данных
-
не стабильная (одинаковые элементы могут поменять порядок)
сложная реализация
heapq

[4, 10, 3, 5, 1]
        10
      /    \
    5       3
  /           \
4              1
[1, 5, 3, 4, 10]
[1, 5, 3, 4]
"""

def heapify(arr, n, i, ascending):
    largest_or_smallest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if ascending:
        if left < n and arr[left] > arr[largest_or_smallest]:
            largest_or_smallest = left
        if right < n and arr[right] > arr[largest_or_smallest]:
            largest_or_smallest = right
    else:
        if left < n and arr[left] < arr[largest_or_smallest]:
            largest_or_smallest = left
        if right < n and arr[right] < arr[largest_or_smallest]:
            largest_or_smallest = right

    if largest_or_smallest != i:
        arr[i], arr[largest_or_smallest] = arr[largest_or_smallest], arr[i]
        heapify(arr, n, largest_or_smallest, ascending)


def heap_sort(arr, ascending=True):
    n = len(arr)

    #строим кучу
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i, ascending)

    #сортируем, вытаскивая корень и уменьшая размер кучи
    for i in range(n - 1, 0, -1):

        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0, ascending)
"""
[4, 10, 3, 5, 1]
        10
       /  \
      5    3
     /
    4
[10, 5, 3, 4, 1]
меняем 10 и 1
[1, 5, 3, 4, 10]
heapigy([1, 5, 3, 4]) 
"""

"""
1 выбираем опорный элемент
2 переставляем. Слева все элементы меньше него, справа больше
3 рекурсивно применяем к левому и правому подмассивам
4 1/0 - базовый случай

[5, 3, 8, 4, 2, 7, 1, 7]
5
меньше [3, 4, 2, 1]
больше [8, 7, 6]

первый 
последний
случайный
середина
медиана 
"""
def quick_sort(arr, low, high):
    if low < high:
        pivot_index = partition(arr, low, high)
        quick_sort(arr, low, pivot_index - 1)
        quick_sort(arr, pivot_index + 1, high)

def partition(arr, low, high, ascending=True):
    pivot = arr[high]
    i = low - 1

    for j in range(low, high):
        if (ascending and arr[j] <= pivot) or (not ascending and arr[j] >= pivot):
            i += 1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

"""
вставками, слиянием

run (прогоны) - отсортированная часть
[1, 2, 3, 7, 4, 5, 6, 10]
[1, 2, 3, 7]
[4, 5, 6, 10]

1 нахождение runs
2 вставками
3 слияние runs
4 merge policy условия слияния 
"""
def insertion_sort(arr, left, right):
    for i in range(left + 1, right + 1):
        key = arr[i]
        j = i - 1
        while j >= left and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key


def merge(arr, l, m, r):
    left = arr[l:m+1]
    right = arr[m+1:r+1]
    i = j = 0
    k = l
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1
        k += 1
    while i < len(left):
        arr[k] = left[i]
        i += 1
        k += 1
    while j < len(right):
        arr[k] = right[j]
        j += 1
        k += 1


def timsort(arr):
    n = len(arr)
    RUN = 32  # длина минимального run

    for i in range(0, n, RUN):
        insertion_sort(arr, i, min(i + RUN - 1, n - 1))

    size = RUN
    while size < n:
        for left in range(0, n, 2 * size):
            mid = min(left + size - 1, n - 1)
            right = min(left + 2 * size - 1, n - 1)
            if mid < right:
                merge(arr, left, mid, right)
        size *= 2

сложность_алгоритмов.py
n = 10

for i in range(n):  # O(n)
    print(i)


count = 0
while count < n:  # O(n)
    print(count)
    count += 1

print(56)  # O(1)
data = {
    'key': 'value',
}

print(data['key'])  # O(1)


for i in range(n):  # O(n)
    if i == n - 1:
        print(i)

print()

# O(n^2)
for i in range(n):  # O(n)
    for j in range(n):  # O(n)
        if i == j:
            if i == n - 1:
                print(i)
                print(j)

1. lesson4

1


1. lesson5

lambda map filter reduce.py
def sqr1(number):
    """docstring полное описание"""
    return number * number

sqr = lambda x : x * x

def printf(some_list, func):
    """docstring"""
    for i in some_list:
        print(func(i))


list1 = list(range(5))

printf(list1, sqr1)
printf(list1, lambda x : x * x)

print(sqr(5))
"""
map - применяем Function ко всем элементам последовательности
map(функция, последовательность)
"""
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)

def square(x):
    return x ** 2

squared = list(map(square, numbers))
print(squared)

for i in map(sqr1, numbers):
    print(i)

list2 = list(map(sqr1, numbers))
print(list2)


"""
filter - фильтрация, запишет те, для которых f возвращает True
filter(функция, последовательность)
f возвращает True False
"""

even_numbers = list(filter(lambda x : x % 2 == 0, numbers))

def is_even(x):
    return x % 2 == 0

for i in filter(lambda x : x % 2 == 0, list1):
    print(i)
list1 = list(filter(lambda x : x % 2 == 0, list1))
print(list1)
fib = lambda n : n if n <= 1 else fib(n - 1) + fib(n - 2)
fact = lambda n : 1 if n == 0 else n * fact(n - 1)

#vfact = lambda f: f(f, n)
#infact = lambda n :
fact2 = lambda f , x :  1 if x == 0 else x * f(f, x - 1)
ifact = lambda n : (lambda f: f(f, n))(fact2)

list1 = list(map(fib, range(10)))
list2 = list(map(fact, range(10)))
print(list1)
print(list2)


from functools import reduce

"""
reduce - 
reduce(функция, последовательность, начальное значение)
функция принимает два аргумента
"""
numbers = [1, 2, 3, 4, 5]

product = reduce(lambda  x, y : x * y, numbers)
print(product)
"""
----------1-----------
x = 1 = numbers[0]
y = 2 = numbers[1]
lambda  x, y : x * y

1 * 2
= 2 - начальное накопительное значение

----------2-----------
x = 2 = накопительное
y = 3 = numbers[2]
lambda  x, y : x * y

2 * 3
= 6

6 * 4 = 24
24 * 5 = 120

"""

def multiply(x, y):
    return x * y

product2 = reduce(multiply, numbers)

"""

filter - оставить четные 
map - возвести в квадрат
reduce - сложить все квадраты
"""

# from functools import reduce
numbers = [1, 2, 3, 4, 5]

result = reduce(
    lambda x, y: x + y,
    map(
        lambda x: x ** 2,
        filter(lambda x: x % 2 == 0, numbers)
    )
)

print(result)






multuply = lambda x : lambda y : x * y
double = multuply(3)
print(double(5))

curried_function = lambda x : lambda y : lambda z : x + y + z
add_5 = curried_function(2)(3)
print(add_5(4))


def curried_add(x):
    return lambda y : x + y

def add(x, y):
    return x + y

#add_3 = partial(add, 3)

#import logging

def log(level):
    return lambda message: f"[{level.upper()}] {message}"

info = log("INFO")
error = log("ERROR")

print(info("This is an info message"))

"""
Напишите каррированную функцию с lambda, которая умножает число на коэффициент и добавляет смещение
Функция должна принимать два параметра: коэффициент и смещение
Вернуть замыкание, которое принимает одно число и выполняет вычисление

результат=(число×коэффициент)+смещение
"""

def create_transformer(coefficient):
    return lambda offset : lambda number : (number * coefficient) + offset

transformer = create_transformer(2)

add_3 = transformer(3)
add_5 = transformer(5)

print(add_3(10))

print(add_5(10))






strlist = ['fsd1231', 'fsd1231', 'fsd1231', 'fsd1231']
"""сделать первые буквы заглавными map, lambda"""

strlist = list(map(lambda n : n.title(), strlist))

numlist = ['1 2 3 4', '1 2 3 4', '1 2 3 4', '1 2 3 4']
"""найти сумму элементов map, lambda, .split()numlist = [10, 10, 10, 10]"""
numlist = list(map(lambda s: sum(map(int, s.split())), numlist))

strlist = ['121', 'fsd1231', 'fsd1231', 'Rsd1231', 'Rsd1231']
"""список слов с заглавной буквы, сделать их прописными filter
strlist = ['rsd1231', 'rsd1231']"""
strlist = list(map(lambda x : x.lower(), filter(lambda x : x.istitle(), strlist)))

strlist = ['121', '123321', 'fsd1231', 'Rsd1231', 'Rsd1231']
"""одинаково слева направо strlist = ['121', '123321']"""

strlist = list(filter(lambda x : x == x[::-1], strlist))

strlist = ['a', '123321', 'fsd1231', 'ii', 'Rsd1231']
"""с любой гласной aeiouyAEIOUY"""
strlist = ['a', 'ii']
b = "aeiouyAEIOUY"
strlist = list(filter(lambda x: any(ch in b for ch in x), strlist))
print()
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
# Удвойте каждый элемент списка чисел.
print(list(map(lambda x : x * 2, numbers)))

# Отфильтруйте чётные числа из списка.
print(list(filter(lambda x : x % 2 == 0, numbers)))

# Преобразуйте все строки в списке в верхний регистр.
strlist = ['fsd1231', 'fsd1231', 'fsd1231', 'fsd1231']
print(list(map(lambda s : s.upper(), strlist)))

# Отфильтруйте положительные числа из списка.
print(list(filter(lambda x : x > 0, numbers)))

# Вычислите квадраты всех чисел в списке.
print(list(map(lambda x : x ** 2, numbers)))

# Отфильтруйте чётные числа, а затем возведите их в квадрат. map filter
print(list(map(lambda x : x ** 2, filter(lambda x : x % 2 == 0, numbers))))

1. lesson6

classes.py
class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author
    
    def get_info(self):
        return f"Книга: '{self.title}'. Автор: {self.author}."


class Student:
    def __init__(self, name, grades=None):
        self.name = name
        self.grades = grades if grades is not None else []
    
    def add_grade(self, grade):
        self.grades.append(grade)
    
    def get_average(self):
        if not self.grades:
            return 0
        return sum(self.grades) / len(self.grades)


class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width
    
    def calculate_area(self):
        return self.length * self.width
    
    def calculate_perimeter(self):
        return 2 * (self.length + self.width)


class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.balance = balance
    
    def deposit(self, amount):
        self.balance += amount
    
    def withdraw(self, amount):
        if amount > self.balance:
            return False
        self.balance -= amount
        return True


class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def bark(self):
        print("Гав!")
    
    def human_age(self):
        return self.age * 7


class Point2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def distance_to_zero(self):
        return (self.x**2 + self.y**2)**0.5


class Lamp:
    def __init__(self, is_on=False):
        self.is_on = is_on
    
    def switch_on(self):
        self.is_on = True
    
    def switch_off(self):
        self.is_on = False
    
    def status(self):
        if self.is_on:
            print("Светильник включен")
        else:
            print("Светильник выключен")


class SocialProfile:
    def __init__(self, username, posts=None):
        self.username = username
        self.posts = posts if posts is not None else []
    
    def add_post(self, text):
        self.posts.append(text)
    
    def show_posts(self):
        for post in self.posts:
            print(post)


class CoffeeMachine:
    def __init__(self, water_level=0):
        self.water_level = water_level
    
    def add_water(self, amount):
        self.water_level += amount
    
    def make_coffee(self):
        if self.water_level >= 200:
            self.water_level -= 200
            return True
        else:
            print("Недостаточно воды для приготовления кофе")
            return False


class GameCharacter:
    def __init__(self, name, health=100, damage=10):
        self.name = name
        self.health = health
        self.damage = damage
    
    def attack(self, other_character):
        other_character.health -= self.damage

pz1.md
### Общая инструкция:
Для каждого задания создайте новый класс. Не забудьте использовать конструктор (`__init__`) для инициализации атрибутов и методы с первым аргументом `self` для работы с этими атрибутами.

---

### Задания:

**1. Книга**
> Создай класс `Book`. В конструкторе инициализируй атрибуты `title` (название) и `author` (автор). Создай метод `get_info(self)`, который возвращает строку в формате: `"Книга: '[название]'. Автор: [автор]."`.

**2. Студент**
> Создай класс `Student`. В конструкторе инициализируй атрибуты `name` (имя) и `grades` (список оценок, по умолчанию пустой список). Создай метод `add_grade(self, grade)`, который добавляет новую оценку в список `grades`, и метод `get_average(self)`, который возвращает средний балл студента.

**3. Прямоугольник**
> Создай класс `Rectangle`. В конструкторе инициализируй атрибуты `length` (длина) и `width` (ширина). Создай два метода: `calculate_area(self)` (вычисляет и возвращает площадь) и `calculate_perimeter(self)` (вычисляет и возвращает периметр).

**4. Банковский счет**
> Создай класс `BankAccount`. В конструкторе инициализируй атрибуты `owner` (владелец) и `balance` (баланс, по умолчанию 0). Создай методы `deposit(self, amount)` (для пополнения счета) и `withdraw(self, amount)` (для снятия денег). Учти, что нельзя снять больше, чем есть на счете.

**5. Собака**
> Создай класс `Dog`. В конструкторе инициализируй атрибуты `name` (кличка) и `age` (возраст). Создай методы `bark(self)` (выводит в консоль сообщение "Гав!"), и `human_age(self)` (возвращает возраст собаки в "человеческих" годах, умножая возраст на 7).

**6. Точка в 2D-пространстве**
> Создай класс `Point2D`. В конструкторе инициализируй атрибуты `x` и `y` (координаты). Создай метод `distance_to_zero(self)`, который вычисляет и возвращает расстояние от этой точки до начала координат (0, 0). Формула: `(x**2 + y**2)**0.5`.

**7. Простой Светильник**
> Создай класс `Lamp`. В конструкторе инициализируй атрибут `is_on` (состояние: включен или выключен, по умолчанию `False`). Создай методы `switch_on(self)` (включает светильник), `switch_off(self)` (выключает его) и `status(self)` (выводит "Светильник включен" или "Светильник выключен").

**8. Профиль в социальной сети**
> Создай класс `SocialProfile`. В конструкторе инициализируй атрибуты `username` (имя пользователя) и `posts` (список постов, по умолчанию пустой). Создай метод `add_post(self, text)`, который добавляет новый пост в список, и метод `show_posts(self)`, который выводит все посты пользователя в консоль.

**9. Кофе-машина (упрощенная)**
> Создай класс `CoffeeMachine`. В конструкторе инициализируй атрибут `water_level` (уровень воды, по умолчанию 0). Создай методы `add_water(self, amount)` (добавляет воду), `make_coffee(self)` (готовит кофе, если воды больше 200 мл, и уменьшает уровень воды на 200; если воды мало, выводит сообщение об ошибке).

**10. Игровой персонаж**
> Создай класс `GameCharacter`. В конструкторе инициализируй атрибуты `name` (имя), `health` (здоровье, например, 100) и `damage` (урон, который наносит персонаж). Создай метод `attack(self, other_character)`, который уменьшает здоровье `other_character` на величину урона `self.damage`.

test_classes.py
import pytest
import math
from io import StringIO
import sys
from classes import Book, Student, Rectangle, BankAccount, Dog, Point2D, Lamp, SocialProfile, CoffeeMachine, GameCharacter


class TestBook:
    def test_book_initialization(self):
        book = Book("Война и мир", "Лев Толстой")
        assert book.title == "Война и мир"
        assert book.author == "Лев Толстой"
    
    def test_get_info(self):
        book = Book("1984", "Джордж Оруэлл")
        expected = "Книга: '1984'. Автор: Джордж Оруэлл."
        assert book.get_info() == expected
    
    def test_get_info_with_unicode(self):
        book = Book("Мастер и Маргарита", "Михаил Булгаков")
        info = book.get_info()
        assert "Мастер и Маргарита" in info
        assert "Михаил Булгаков" in info


class TestStudent:
    def test_student_initialization(self):
        student = Student("Иван")
        assert student.name == "Иван"
        assert student.grades == []
    
    def test_student_with_initial_grades(self):
        student = Student("Мария", [5, 4, 5])
        assert student.grades == [5, 4, 5]
    
    def test_add_grade(self):
        student = Student("Петр")
        student.add_grade(5)
        student.add_grade(4)
        assert student.grades == [5, 4]
    
    def test_get_average_empty(self):
        student = Student("Анна")
        assert student.get_average() == 0
    
    def test_get_average(self):
        student = Student("Сергей")
        student.add_grade(5)
        student.add_grade(4)
        student.add_grade(3)
        assert student.get_average() == 4.0
    
    def test_get_average_precise(self):
        student = Student("Ольга", [5, 4, 4])
        assert abs(student.get_average() - 4.333333) < 0.001


class TestRectangle:
    def test_rectangle_initialization(self):
        rect = Rectangle(5, 3)
        assert rect.length == 5
        assert rect.width == 3
    
    def test_calculate_area(self):
        rect = Rectangle(10, 5)
        assert rect.calculate_area() == 50
    
    def test_calculate_perimeter(self):
        rect = Rectangle(10, 5)
        assert rect.calculate_perimeter() == 30
    
    def test_square(self):
        square = Rectangle(4, 4)
        assert square.calculate_area() == 16
        assert square.calculate_perimeter() == 16
    
    def test_float_dimensions(self):
        rect = Rectangle(3.5, 2.5)
        assert rect.calculate_area() == 8.75
        assert rect.calculate_perimeter() == 12.0


class TestBankAccount:
    def test_account_initialization(self):
        account = BankAccount("Иван Петров")
        assert account.owner == "Иван Петров"
        assert account.balance == 0
    
    def test_account_with_initial_balance(self):
        account = BankAccount("Мария Сидорова", 1000)
        assert account.balance == 1000
    
    def test_deposit(self):
        account = BankAccount("Петр Иванов")
        account.deposit(500)
        assert account.balance == 500
        account.deposit(300)
        assert account.balance == 800
    
    def test_withdraw_success(self):
        account = BankAccount("Анна Смирнова", 1000)
        result = account.withdraw(500)
        assert result is not False
        assert account.balance == 500
    
    def test_withdraw_failure(self):
        account = BankAccount("Сергей Козлов", 100)
        result = account.withdraw(200)
        assert result == False
        assert account.balance == 100
    
    def test_withdraw_exact_amount(self):
        account = BankAccount("Ольга Попова", 500)
        account.withdraw(500)
        assert account.balance == 0


class TestDog:
    def test_dog_initialization(self):
        dog = Dog("Шарик", 5)
        assert dog.name == "Шарик"
        assert dog.age == 5
    
    def test_bark(self, capsys):
        dog = Dog("Бобик", 3)
        dog.bark()
        captured = capsys.readouterr()
        assert "Гав!" in captured.out
    
    def test_human_age(self):
        dog = Dog("Рекс", 2)
        assert dog.human_age() == 14
    
    def test_human_age_older_dog(self):
        dog = Dog("Тузик", 10)
        assert dog.human_age() == 70


class TestPoint2D:
    def test_point_initialization(self):
        point = Point2D(3, 4)
        assert point.x == 3
        assert point.y == 4
    
    def test_distance_to_zero(self):
        point = Point2D(3, 4)
        assert point.distance_to_zero() == 5.0
    
    def test_distance_to_zero_origin(self):
        point = Point2D(0, 0)
        assert point.distance_to_zero() == 0.0
    
    def test_distance_to_zero_negative(self):
        point = Point2D(-3, -4)
        assert point.distance_to_zero() == 5.0
    
    def test_distance_to_zero_float(self):
        point = Point2D(1.0, 1.0)
        expected = math.sqrt(2)
        assert abs(point.distance_to_zero() - expected) < 0.0001


class TestLamp:
    def test_lamp_initialization_default(self):
        lamp = Lamp()
        assert lamp.is_on == False
    
    def test_lamp_initialization_on(self):
        lamp = Lamp(True)
        assert lamp.is_on == True
    
    def test_switch_on(self):
        lamp = Lamp()
        lamp.switch_on()
        assert lamp.is_on == True
    
    def test_switch_off(self):
        lamp = Lamp(True)
        lamp.switch_off()
        assert lamp.is_on == False
    
    def test_status_on(self, capsys):
        lamp = Lamp(True)
        lamp.status()
        captured = capsys.readouterr()
        assert "Светильник включен" in captured.out
    
    def test_status_off(self, capsys):
        lamp = Lamp()
        lamp.status()
        captured = capsys.readouterr()
        assert "Светильник выключен" in captured.out


class TestSocialProfile:
    def test_profile_initialization(self):
        profile = SocialProfile("user123")
        assert profile.username == "user123"
        assert profile.posts == []
    
    def test_profile_with_initial_posts(self):
        profile = SocialProfile("user456", ["Первый пост"])
        assert len(profile.posts) == 1
    
    def test_add_post(self):
        profile = SocialProfile("user789")
        profile.add_post("Мой первый пост")
        profile.add_post("Второй пост")
        assert len(profile.posts) == 2
        assert profile.posts[0] == "Мой первый пост"
    
    def test_show_posts(self, capsys):
        profile = SocialProfile("user000")
        profile.add_post("Пост 1")
        profile.add_post("Пост 2")
        profile.show_posts()
        captured = capsys.readouterr()
        assert "Пост 1" in captured.out
        assert "Пост 2" in captured.out
    
    def test_show_posts_empty(self, capsys):
        profile = SocialProfile("user111")
        profile.show_posts()
        captured = capsys.readouterr()
        assert captured.out == ""


class TestCoffeeMachine:
    def test_machine_initialization(self):
        machine = CoffeeMachine()
        assert machine.water_level == 0
    
    def test_machine_with_initial_water(self):
        machine = CoffeeMachine(500)
        assert machine.water_level == 500
    
    def test_add_water(self):
        machine = CoffeeMachine()
        machine.add_water(300)
        assert machine.water_level == 300
        machine.add_water(200)
        assert machine.water_level == 500
    
    def test_make_coffee_success(self):
        machine = CoffeeMachine(300)
        result = machine.make_coffee()
        assert result is not False
        assert machine.water_level == 100
    
    def test_make_coffee_insufficient_water(self, capsys):
        machine = CoffeeMachine(100)
        result = machine.make_coffee()
        captured = capsys.readouterr()
        assert result == False
        assert machine.water_level == 100
        assert "Недостаточно воды" in captured.out or "воды" in captured.out.lower()
    
    def test_make_coffee_exact_amount(self):
        machine = CoffeeMachine(200)
        machine.make_coffee()
        assert machine.water_level == 0


class TestGameCharacter:
    def test_character_initialization_default(self):
        char = GameCharacter("Герой")
        assert char.name == "Герой"
        assert char.health == 100
        assert char.damage == 10
    
    def test_character_initialization_custom(self):
        char = GameCharacter("Воин", 150, 20)
        assert char.health == 150
        assert char.damage == 20
    
    def test_attack(self):
        hero = GameCharacter("Герой", 100, 15)
        enemy = GameCharacter("Враг", 100, 10)
        hero.attack(enemy)
        assert enemy.health == 85
    
    def test_multiple_attacks(self):
        hero = GameCharacter("Герой", 100, 20)
        enemy = GameCharacter("Враг", 100, 10)
        hero.attack(enemy)
        hero.attack(enemy)
        assert enemy.health == 60
    
    def test_attack_reduces_to_negative(self):
        hero = GameCharacter("Герой", 100, 150)
        enemy = GameCharacter("Враг", 100, 10)
        hero.attack(enemy)
        assert enemy.health == -50


if __name__ == "__main__":
    pytest.main([__file__, "-v"])

1.2. oop

abst.py
from abc import ABC, abstractmethod
#создать абстрактный MClass с несколькими абстрактными методами\
# в другом файле импортировать его и реализовать в наследнике
class Animal(ABC):
    info = 'animal'

    @abstractmethod
    def __init__(self):
        pass

    @abstractmethod
    def make_voice(self):
        pass

    @abstractmethod
    def walk(self):
        pass

class MClass(ABC):
    @classmethod
    @abstractmethod
    def add(cls):
        pass

    @classmethod
    @abstractmethod
    def substruct(cls):
        pass

clases.py
from abc import ABC

"""экземпляр - конкретный объект созданный на основе класса
атрибут(поле) класса - принадлежит самому классу и разделяется всеми экземплярами
атрибут(поле) экземпляра - принадлежит конкретному объекту  и уникален для каждого экземпляра
метод экземпляра def - функция конкретного объекта
метод класса @classmethod- работает с классом в целом
метод статический @staticmethod- не зависит от класса или объекта, нет доступа, но относится
конструктор __init__- вызывается при создании объекта
наследование - новый класс на основе существующего
полиморфизм - возможность использовать один и тот же интерфейс (метод) для объектов разных классов
инкапсуляция __ - скрытие деталей
свойство - атрибут поволяющий управлять доступом к данным через гет сет дел
дескриптор - объект который оперделяет поведение атрибутов класса __гет__ __сет__ __удалить__
магические методы - __???__ для перегрузки операторов
абстрактный класс - используется как шаблон, указываются методы для реализации
метакласс - определяет поведение других классов
множественное наследование
MRO - порядок поиска методов в иерархии наследования
перегрузка - переопределение поведения операторов и функций
сеттер - устанавливает значение атрибута
геттер - возвращает значение атрибута
делитер - метод удаляет атрибут
приватный атрибут - не предназначен для доступа извне
декораторы - через @
миксины - классы с доп функционалом, не предназначены для самостоятельного использования
"""

class Person:

    health = 100

    def __init__(self, name, age, is_student=False):
        self.name = name
        self.age = age
        self.is_student = is_student
        self.gender = None

    def invert_is_student(self):
        self.is_student = not self.is_student

    @staticmethod
    def to_learn():
        print('im learning')

    @classmethod
    def print_health(cls):
        print(cls.health)

Person.print_health()
print(Person.health)

num = 1
Matvey = Person('name', 18)
Matvey2 = Person('name', 18)
Matvey2 = Person('name', 18)
print(Matvey.is_student)
Matvey.invert_is_student()
print(Matvey.is_student)
Matvey.to_learn()


# создать математический класс с атрибутом количества
# несколько методов cls которые возвращают генератор
# init принимает список строк с желаемыми функциями
# метод который их выводит

class MClass:
    length = 5

    def __init__(self, func):
        self.func = func

    def print_func(self):
        print(self.func)

    @classmethod
    def gen1(cls):
        return [i for i in range(cls.length)]

    @classmethod
    def gen2(cls):
        return [i**2 for i in range(cls.length)]

print(MClass.length)
print(MClass.gen1())
print(MClass.gen2())
MyMath = MClass(['sum', 'pow'])
MyMath.print_func()
# MClass от него унаследовать в тригонометрию
# в триг мат функции
# иниц предыдущее и 1 новое
# из триг вызвать методы MClass
from math import *
class Trig(MClass):

    def __init__(self, func, inp):
        super().__init__(func)
        self.inp = inp

    def trig_sin(self):
        return sin(self.inp)

    def trig_cos(self):
        return cos(self.inp)

    def greet(self):
        super().print_func()

import collections

from abst import Animal
class Cat(Animal):
    def __init__(self, name):
        self.name = name
        self.__owner = 'me'

    def make_voice(self):
        print(f'{self.name} maked voice')

    def walk(self):
        print(f'{self.name} walked')

    def print_owner(self):
        print(self.__owner)

    @classmethod
    def info(cls):
        print(super().info)

MyCat = Cat('cat')
MyCat.make_voice()
MyCat.walk()
MyCat.print_owner()
Cat.info()
from abst import MClass
class Alg(MClass):
    @classmethod
    def add(cls):
        return 5
    @classmethod
    def substruct(cls):
        return 7

class Dog(Animal):
    pass

decorators.py
"""def decorator(func):
    def wrapper():
        print("декоратор сработал до вызова функции")
        func()
        print("после вызова")
    return wrapper

@decorator
def say_hello():
    print('функция')

say_hello()"""
import time


"""def decorator(func):
    def wrapper(*args, **kwargs):
        print(f"вызывается {func.__name__} с аргументами {args}, {kwargs}")
        result = func(*args, **kwargs)
        print(f"функция {func.__name__} завершила выполнение")
        return result
    return wrapper

@decorator
def add(a, b):
    return a + b

print(add(3, 5))"""
"""
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                func(*args, **kwargs)
        return wrapper
    return decorator


@repeat(3)
def say_hi():
    print('hi')

say_hi()"""

"""def methor_decorator(func):
    def wrapper(self, *args, **kwargs):
        print(f"вызов метода {func.__name__}")
        return func(self, *args, **kwargs)
    return wrapper

class Example:
    @methor_decorator
    def greet(self):
        print("привет от класса")

obj = Example()
obj.greet()
"""
"""from functools import wraps

def decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print("выполняетя декорированная функция")
        return func(*args, **kwargs)
    return wrapper

@decorator
def example():
    """"""эта функция возвращает hello""""""
    return "hello"

print(example.__name__)
print(example.__doc__)"""
"""
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b

print(MathUtils.add(3, 5))

class Counter:
    count = 0
    @classmethod
    def increment(cls):
        cls.count += 1

Counter.increment()
Counter.increment()
print(Counter.count)

""""""
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        if value < 0:
            raise ValueError("")
        self._radius = value

    @radius.deleter
    def radius(self):
        raise AttributeError("")



c = Circle(5)
print(c.radius)
#c.radius = -3
del c.radius"""

"""from functools import lru_cache

class Fibonacci:
    @lru_cache(maxsize=None)
    def fib(self, n):
        if n < 2:
            return n
        return self.fib(n - 1) + self.fib(n - 2)

f = Fibonacci()
print(f.fib(50))

from contextlib import contextmanager

class FileHandler:
    @contextmanager
    def open_file(self, filename):
        file = open(filename, 'w')
        try:
            yield file
        finally:
            file.close()

handler = FileHandler()
with handler.open_file("test.txt") as f:
    f.write("hi")



from functools import singledispatchmethod

class Printer:
    @singledispatchmethod
    def show(self, value):
        raise NotImplementedError("")

    @show.register
    def _(self, value: int):
        print(f"целое число: {value}")

    @show.register
    def _(self, value: str):
        print(f"строка {value}")

printer = Printer()
printer.show(10)
printer.show("hi")

from functools import  cached_property

class ExpensiveComputation:
    def __init__(self, x):
        self.x = x

    @cached_property
    def compute(self):
        print("выполнение сложных вычислений")
        return self.x ** 2

obj = ExpensiveComputation(10)
print(obj.compute)
print(obj.compute)


from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int

p1 = Point(10, 20)
p2 = Point(10, 20)
print(p1)
print(p1 == p2)"""
"""
from functools import total_ordering

@total_ordering
class Student:
    def __init__(self, name, grade):
        self.name = name
        if grade > 0:
            self.grade = grade
        else:
            throw Exception

    def __eq__(self, other):
        return self.grade == other.grade

    def __lt__(self, other):
        return self.grade < other.grade

s1 = Student("q", 90)
s2 = Student("b", 85)

print(s1 > s2)
print(s1 <= s2)


def singleton(cls):
    instances = {}

    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return  get_instance

@singleton
class Database:
    def __init__(self):
        print("создали")

db1 = Database()
db2 = Database()

print(db1 is db2)


@classproperty
"""
"""аналог @propertry для класса"""

"""



@timing

@validate_args

@log_methods"""
"""# ----------------------------------------------------------------

def my_decorator(func):
    def wrapper():
        print("что-то перед")
        func()
        print("что-то после")
    return wrapper


@my_decorator
def say_hello():
    print("hello")
# ----------------------------------------------------------------

def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                func(*args, **kwargs)
        return wrapper
    return decorator


@repeat(3)
def say_hi():
    print('hi')
# ----------------------------------------------------------------

def methor_decorator(func):
    def wrapper(self, *args, **kwargs):
        print(f"вызов метода {func.__name__}")
        return func(self, *args, **kwargs)
    return wrapper

class Example:
    @methor_decorator
    def greet(self):
        print("привет от класса")

obj = Example()
obj.greet()
# ----------------------------------------------------------------

class MyDecorator:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print("что-то перед")
        result = self.func(*args, **kwargs)
        print("что-то после")
        return result

@MyDecorator
def say_hi():
    print('hi')

say_hi()
# ----------------------------------------------------------------"""

"""
1
logger - декоратор, для логирования вызова функций 
должен выводить
имя
аргументы
время вызова
import time
time()
"""
"""import time
def logger(func):
    def wrapper(*args, **kwargs):
        timestamp = time.time()
        print(f"[{timestamp}] вызов {func.__name__}")
        print(f"args={args}, kwargs={kwargs}")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(x, y):
    return x + y

add(4, 5)
# ----------------------------------------------------------------"""

"""
timer / timing
будет замерять время выполнения функции и выводить
"""
"""def timer(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"f{func.__name__} за {end_time - start_time}с.")
    return wrapper

@timer
def add(x, y):
    time.sleep(1)
    return x + y

add(3, 5)
# ----------------------------------------------------------------
"""
"""
current_user = "admin"
check_access
проверяет имеет ли пользователь доступ к функции
принимает уровень доступа
"""
"""current_user = "admin"

def check_access(role):
    def decorator(func):
        def wrapper(*args, **kwargs):
            if current_user == role:
                return func(*args, **kwargs)
            else:
                print('нет доступа')
        return wrapper
    return decorator

@check_access('admin')
def delete_db():
    print('удалено')

delete_db()
# ----------------------------------------------------------------"""

"""
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                func(*args, **kwargs)
        return wrapper
    return decorator


@repeat(3)
def say_hi():
    print('hi')
    
retry
повторять вызов функции n раз, если она завершилась с ошибкой

random < 0.5
    raise ошибка
успех
"""
# ----------------------------------------------------------------
"""
def retry(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attemp in range(1, n + 1):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"попытка {attemp}: ошибка")
                    if attemp == n:
                        raise e
        return wrapper
    return decorator

@retry(3)
def risky_func():
    import random
    if random.random() < 0.5:
        raise ValueError("ошибка")
    return "успех"

print(risky_func())"""
# ----------------------------------------------------------------
"""
rate_limit
ограничивает частоту вызовов 
если вызывается чаще раз в 5 секунд, выводим предупреждение
"""
"""def rate_limit(interval):
    last_called = 0

    def decorator(func):
        def wrapper(*args, **kwargs):
            nonlocal last_called
            elapsed = time.time() - last_called
            if elapsed < interval:
                print(f"слишком частые вызовы. Подождать {interval - elapsed:.3f} с.")
                return
            last_called = time.time()
            return func(*args, **kwargs)
        return wrapper
    return decorator

@rate_limit(5)
def send_request():
    print("запрос отправлен")

send_request()
time.sleep(3)
send_request()
time.sleep(2)
send_request()"""
#----------------------------------------------------------------
"""
to_upper
преобразует результат ф в верх рег
"""
"""def to_upper(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result.upper()

    return wrapper

@to_upper
def say_hi():
    return "hi"

print(say_hi())"""
#----------------------------------------------------------------

"""
validate_args
проверка что аргументы ф положительные
"""
"""
def validate_args(func):
    def wrapper(*args, **kwargs):
        for arg in args:
            if not isinstance(arg, (int, float)) or arg < 0:
                raise ValueError("")
        return func(*args, **kwargs)
    return wrapper

@validate_args
def multiply(a, b):
    return a * b

print(multiply(3, 5))
print(multiply(-3, 5))"""
#----------------------------------------------------------------

"""
count_calls
считает количество вызовов функции, выводит при каждом вызове
"""
def count_calls(func):
    def wrapper(*args, **kwargs):
        wrapper.call_count += 1
        print(f"f {func.__name__} вызвана {wrapper.call_count} р.")
        return func(*args, **kwargs)
    wrapper.call_count = 0
    return wrapper

@count_calls
def say_hi():
    print("hi")

say_hi()
say_hi()
say_hi()

encapsulation.py
class BankAccount:
    def __init__(self, name, balance=0):
        self.name = name
        self.__balance = balance
        self._balance = balance

    def income(self, summ):
        self.__balance += summ

    def print_bal(self):
        print(self.__balance)


MyAcc = BankAccount('matvey')
MyAcc.income(1)
MyAcc.print_bal()
# сделать длину MClass приватной

inheritance.py
class Animal:
    def __init__(self, name, height, weight):
        self.name = name
        self.height = height
        self.weight = weight

    def make_voice(self):
        print(f'{self.name} maked voice')

class Cat(Animal):
    def __init__(self, name, height, weight, color):
        super().__init__(name, height, weight)
        self.color = color

    def greet(self):
        super().make_voice()

cat = Animal('вася', 12, 12)

Cat = Cat('вася', 12, 12, 'black')
Cat.make_voice()
Cat.greet()

# MClass от него унаследовать в тригонометрию
# в триг мат функции
# иниц предыдущее и 1 новое
# из триг вызвать методы MClass

myClasses.py
"""
экземпляр класса - объект построенный по шаблону классу
атрибуты (свойства/поля/переменные) - данные в классе
    атрибуты класса - общие для всех объектов
    атрибуты экземпляра класса - принадлежат конкретному объекту
методы - функции в классе
    обычные - say_hello - метод экземпляра класса
    классовые - @classmethod - получают cls первым аргументов, сам класс, а не объект
    статические @staticmethod - не получает ни self ни cls, просто функции внутри класса
магические методы () - переопределяют стандартное поведение
наследование
    super() - функция, вызывать методы родителя
    mro - method resolution order - порядок разрешения методов
    isinstance() - проверяет, является ли объект экземпляром класса или его потомка
    issubclass() - проверяет, является ли один класс подклассом другого
    object - корневой класс

mixins - миксы - небольшие классы, добавляющие одну конкретную функцию
абстрактный класс - шаблон - базовый класс - интерфейс (в питоне интерфейсом
является абстрактный класс без реализации), нельзя создать экземпляр, содержит абстрактные методы

    абстрактные методы - методы без реализации @abstactmethod
pass - подразумевает что далее что-то может быть добавлено
... - не подразумевает что далее что-то может быть добавлено
композиция - один класс содержит экземпляр другого, а не наследует его

инкапсуляция
    _ protected
    __ private
    name mangling - переименование

полиформизм - один и тот же метод может делать разное в зависимости от объекта


"""
import math


class MyClass:
    pass

#класс/шаблон
class Person:
    #атрибуты класса
    isHuman = True

    def __init__(self, name, age, high=None):
        #атрибуты экземпляра класса
        self.name = name
        self.age = age
        self.high = high

    def say_hello(self):
        print(f"привет я {self.name} мне {self.age}")

    def birthDay(self):
        self.age += 1

    #плохо
    @staticmethod
    def unHuman():
        Person.isHuman = False

    @classmethod
    def toHuman(cls):
        cls.isHuman = True

#p1 - экземпляр класс
p1 = Person("иван", 20)
#атрибуты (свойства/поля/переменные) - данные в классе
"""
p1
name = "иван"
age = 20
"""

p1.say_hello()
print(p1.age)
p1.birthDay()
print(p1.age)
p1.age = 10
print(p1.age)

print(p1.high)
p1.high = 200
print(p1.high)


print(Person.isHuman)
Person.unHuman()
print(Person.isHuman)

#наследование

class Animal:
    def __init__(self, name):
        self.name = name

    def eat(self):
        print(f"{self.name} ест")

    def move(self):
        print(f"{self.name} двигается")

class Dog(Animal):
    def __init__(self, name: str, age: int):
        self.age = age
        super().__init__(name)

    def make_sound(self):
        print(f"{self.name} гав")

class Cat(Animal):
    def __init__(self, name: str, age: int):
        self.age = age
        super().__init__(name)

    def make_sound(self):
        print(f"{self.name} мяу")

animals = [Dog('1', 1), Cat('1', 1)]
for animal in animals:
    animal.make_sound()
class BlackDog(Dog):
    def __init__(self, name, age, color='black'):
        self.color = color
        super().__init__(name, age)

blackDog = BlackDog('dog', 1)
print(blackDog.color)

class Flyer:
    def action(self):
        print('летит')

class Swimmer:
    def action(self):
        print('плывет')

class Duck(Flyer, Swimmer):
    def action(self):
        print('утра начинает действие')
        super().action()
        
d = Duck()
d.action()

#mro
print()
print(Duck.__mro__)
print()

a = Duck.__mro__
for i in a:
    print(i.__name__)


class A:
    def do(self):
        print("A")

class B:
    def do(self):
        print("B")

class C(A):
    def do(self):
        print("C")

class D(B, C):
    pass

d = D()
d.do()

print(D.__mro__)
"""
isinstance() - проверяет, является ли объект экземпляром класса или его потомка
issubclass() - проверяет, является ли один класс подклассом другого"""
"""print(isinstance(d, D))
print(isinstance(d, B))
print(isinstance(d, C))
print(isinstance(d, A))
print(isinstance(d, object))
print(d is D)
print(d is A)
print(d is object)
print(D is D)
print(D is A)"""

"""print(issubclass(D, B))
print(issubclass(D, A))
print(issubclass(B, C))
print(issubclass(D, object))"""
#mixins - миксы - небольшие классы, добавляющие одну конкретную функцию
class LoggerMixin:
    def log(self, message):
        print(f"[LOG] {message}")

class Service(LoggerMixin, object):
    def process(self):
        self.log("обработка данных начата")

from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

print(bool(Shape.__abstractmethods__))  # проверка на абстрактность

"""
True

False:
""
''
[]
{}
frozenset()
set()
None
0
0.0

if []:
    print(1)
else:
    print(2)

"""

class Square(Shape):
    def __init__(self, side):
        self.side = side

    def area(self) -> float | int:
        return self.side * self.side

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2

c = Circle(5)
print(c.area())

s = Square(5)
print(s.area())

class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass

    @abstractmethod
    def move(self):
        pass


class Base(ABC):
    @abstractmethod
    def hello(self):
        print("привет из Base")

class Product(ABC):
    @property
    @abstractmethod
    def price(self):
        pass

class Report(ABC):
    def print_header(self):
        print("отчет")

    @abstractmethod
    def generate(self):
        pass


class Printable:
    def my_print(self):
        print("печатаю")

class Document(ABC, Printable):
    @abstractmethod
    def get_content(self):
        pass

#mixins - миксы - небольшие классы, добавляющие одну конкретную функцию
"""
нет __init__() и отрибутов
предназначен для наследования совместно с другими
заканчивается на Mixin
"""

class LoggerMixin:
    def log(self, message):
        print(f"[LOG] {message}")

class Worker:
    def work(self):
        print('работаю')

class LogginWorker(LoggerMixin, Worker):
    pass

lw = LogginWorker()
lw.work()
lw.log('готово')


#композиция - один класс содержит экземпляр другого, а не наследует его

class EngineV6:
    def start(self):
        print('двигатель запущен')

class EngineV4:
    def start(self):
        print('двигатель запущен')

class Car:
    def __init__(self, engine):
        self.engine = engine

    def drive(self):
        self.engine.start()
        print("машина едет")



class A:
    def do(self):
        print("A")

class B(A):
    def do(self):
        print("B")

class C(A):
    def do(self):
        print("C")

class D(B, C):
    pass

class Animal:
    def __init__(self, name):
        self.name = name

    def eat(self):
        print(f"{self.name} ест")

    def move(self):
        print(f"{self.name} двигается")

class Dog(Animal):
    def __init__(self, name: str, age: int):
        self.age = age
        super().__init__(name)

    def bark(self):
        print(f"{self.name} гав")

    def move(self):
        #хорошо
        super().move()

        #плохо
        Animal.speak(self)

        print()

#super(CurrentClass, self)

class Parent:
    def greet(self):
        print('hi от родителя')

class Child(Parent):
    def greet(self):
        super(Child, self).greet()
        print("hi от ребенка")
        
class A:
    def do(self):
        print("A")

class B(A):
    def do(self):
        print("B")
        super().do()

class C(A):
    def do(self):
        print("C")
        super().do()

class D(B, C):
    def do(self):
        print("D")
        super().do()

d = D()
d.do()

#super(ClassName, instance).method()

#обычные - публичные - по умолчанию
"""class Person:
    def __init__(self, name):
        self.name = name"""

#protected защищенные
"""class Person:
    def __init__(self, name):
        self._name = name"""

#private приватные
"""class Person:
    def __init__(self, name):
        self.__name = name

person = Person("анна")
#print(person.__name)
print(person._Person__name)"""

class BankAccount:
    def __init__(self, balance):
        self.__balance = balance

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount

    def get_balance(self):
        return self.__balance

account = BankAccount(100)
account.deposit(100)
account.__balance = 0
print(account.get_balance())
print(account.__balance)

class Car:
    def __init__(self, model, fuel):
        self.__model = model
        self.__fuel = fuel

    def drive(self):
        if self.__fuel > 0:
            self.__fuel -= 1
            print(f"{self.__model} поехала. Топливо {self.__fuel}")
        else:
            print(f"{self.__model} не может ехать")

    def get_fuel(self):
        return self.__fuel

car = Car('car', 4)
car.drive()
car.drive()
car.drive()
car.drive()
car.drive()

#type()

class Person:
    def greet(self):
        print("я человек")

def greet(self):
    print("я человек")

Person = type("Person", (object, ), {'greet': greet})

p = Person()
p.greet()

#type(class_name, bases, class_dict)

attrs = {
    'name': 'иван',
    'age': 30,
    'greet': lambda self: print(f"привет, я {self.name}")
}

Person = type('Person', (object, ), attrs)

p = Person()
p.greet()

def __init__(self, name, age):
    self.name = name
    self.age = age

def greet(self):
    print(f"привет, я {self.name}")

attrs = {
    '__init__': __init__,
    'greet': greet
}

Person = type('Person', (object, ), attrs)

class Animal:
    def speak(self):
        print('hi animal')

Dog = type('Dog', (Animal,), {'bark': lambda self: print("гав")})

d = Dog()
d.speak()
d.bark()

class MyClass:
    pass

MyClass = type('MyClass', (object,), {})

#метакласс

x = 5
print(type(x))
print(type(int))

class MyClass:
    def method(self):
        return 'привет'

print(MyClass.__name__)
print(MyClass.mro())
print(MyClass.__bases__)
print(MyClass.__dict__)
print(type(MyClass))

class MyMeta(type):
    def __new__(cls, name, bases, dct):
        print(f"создание класса {name}")
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=MyMeta):
    pass

f = MyClass()

class Meta(type):
    def __new__(cls, name, bases, dct):
        print(f'создание нового класса {name}')
        return super().__new__(cls, name, bases, dct)

    def __init__(cls, name, bases, dct):
        print(f'инициализация класса {name}')
        super().__init__(name, bases, dct)

print(type(type))
print(type(object))
print(isinstance(type, type))
print(issubclass(type, object))
print(issubclass(object, type))

"""
x = 5
class MyClass:
"""

class MyClass(metaclass=MyMeta):
    attr = 10

MyMeta.__new__(MyMeta, "MyClass", (object, ), {'attr': 10})

class UpperAttrMeta(type):
    def __new__(cls, name, bases, dct):
        uppercase_attrs = {}
        for key, value in dct.items():
            if not key.startswith('__'):
                uppercase_attrs[key.upper()] = value
            else:
                uppercase_attrs[key] = value
        return super().__new__(cls, name, bases, uppercase_attrs)

class MyClass(metaclass=UpperAttrMeta):
    foo = 'bar'
    def method(self):
        return 'hello'

print(hasattr(MyClass, 'foo'))
print(hasattr(MyClass, 'FOO'))
print(MyClass.FOO)

registry = {}

class AutoRegisterMeta(type):
    def __init__(cls, name, bases, dct):
        registry[name] = cls
        super().__init__(name, bases, dct)

class Animal(metaclass=AutoRegisterMeta):
    pass

class Dog(Animal):
    pass

print(registry)

class Meta1(type): pass
class Meta2(type): pass

class Base1(metaclass=Meta1): pass
class Base2(metaclass=Meta2): pass

# class Child(Base1, Base2): pass
class Book:
    pass

b1 = Book
print(b1)
"""
str()
len()
+
==
"""

"""
__init__
__str__
__repr__
__new__
"""

"""
== __eq__
!= __ne__
< __lt__
<= __le__
> __gt__
>= __ge__
"""

"""
+ __add_
- __sub__
* __mul__
/ __truediv__
"""
"""
int __int__
float __float__
bool __bool__
"""

"""
доступ по индексу __getitem__
итерация for x in obj __iter__
получение следующего элемента  __next__
= __setitem__
удаление __delitem__

"""

class Quotes:
    def __init__(self, quotes):
        self.quotes = quotes

    def __getitem__(self, index):
        return self.quotes[index]

    def __len__(self):
        return len(self.quotes)

    def __iter__(self):
        return iter(self.quotes)

q = Quotes(['мир', ['труд']])
print(q[1])
for quote in q:
    print(quote)

"""
__enter__
__exit__
"""
"""
__getattr__ если атрибут не найден
__getattribute__ всегда при доступе к атрибуту
__setattr__ при присваивании
__delattr__ при удалении
"""

class Book:
    def __init__(self, title, pages):
        self.title = title
        self.pages = pages

    def __str__(self):
        return f"{self.title} ({self.pages} стр.)"

    def __repr__(self):
        return f"Book {self.title}, {self.pages}"

    def __len__(self):
        return self.pages

    def __eq__(self, other):
        return self.title == other.title

    def __add__(self, other):
        return Book(f"{self.title} + {other.title}", self.pages + other.pages)


b1 = Book("python", 900)
b2 = Book('sky', 700)
print(b1)
print(len(b2))
print(b1 == b2)
b3 = b1 + b2
print(b3)

print(b1 + 3)

point.py
from dataclasses import dataclass
from functools import total_ordering


class CoordinateDescriptor:
    def __get__(self, instance, owner):
        if instance is None:
            return self
        print(f'getting {self.name}')
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        if not isinstance(value, (int, float)):
            raise ValueError('value should be (int, float)')
        print(f'setting {self.name} to {value}')
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        print(f'deleting {self.name}')
        del instance.__dict__[self.name]

    def __set_name__(self, owner, name):
        self.name = name



class Point(CoordinateDescriptor):
    x = CoordinateDescriptor()
    y = CoordinateDescriptor()
    def __init__(self, x=None, y=None):
        self._x = x
        self._y = y

    def point_print(self):
        print(f'Point x={self._x}, y={self._y}')

    def __str__(self):
        return f'Point x={self._x}, y={self._y}'

    def __add__(self, other):
        if not isinstance(other, Point):
            return False
        return Point(self._x + other._x, self._y + other._y)

    def __sub__(self, other):
        if not isinstance(other, Point):
            return False
        return Point(self._x - other._x, self._y - other._y)

    def __eq__(self, other):
        if not isinstance(other, Point):
            return False
        return self._x == other._x and self._y == other._y

    def __mul__(self, scalar):
        if not isinstance(scalar, (int, float)):
            raise ValueError('scalar must be (int, float)')
        return Point(self._x * scalar, self._y * scalar)

    def __truediv__(self, scalar):
        if not isinstance(scalar, (int, float)):
            raise ValueError('scalar must be (int, float)')
        if scalar == 0:
            raise ZeroDivisionError('нельзя 0')
        return Point(self._x / scalar, self._y / scalar)

    def __len__(self):
        if self._x is None and self._y is None:
            return 2
        elif self._x is None or self._y is None:
            return 1
        else:
            return 0

    def __getitem__(self, index):
        if index == 0:
            return self._x
        elif index == 1:
            return self._y
        else:
            raise IndexError('out of range')


p1 = Point(1, 2)
print(p1.x)
print(p1.y)
p1.x = 5
p1.y = 8
p1.point_print()
print(p1)
p2 = Point(1, 2)
p1 += p2
print(p1)
print(p1 == Point(6, 10))
print(p1[0])
print(p1[1])
p3 = Point()

polimorphism.py
class BlackCat:
    @classmethod
    def make_voise(cls):
        print('im BlackCat')

class GreyCat:
    @classmethod
    def make_voise(cls):
        print('im GreyCat')

BlackCat.make_voise()
GreyCat.make_voise()

