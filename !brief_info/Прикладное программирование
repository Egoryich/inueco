exam.txt
блок 1
Оперативная память и объекты в Python. Идентификация объектов (функция id()).
Структура программы на Python. Модули, инструкции, выражения.
Базовые конструкции языка Python. Операторы, переменные, вызовы функций.
Представление чисел в памяти. Битовые операции, модуль ctypes.
Целочисленная арифметика в Python. Операции с целыми числами (int), которые являются числами с произвольной точностью.
Целочисленная арифметика в Python. Поведение целых чисел (int) при умножении и делении.
Операции сложения и вычитания в Python. Арифметические операторы +, -.
Присваивание и ссылочная модель в Python. Переменные как ссылки на объекты.
Работа с байтами и байтовыми строками. Типы bytes и bytearray.
Условные операторы и сравнения в Python. Операторы if, elif, else, операторы сравнения (==, >, < и т.д.).
Безусловное изменение потока выполнения. Оператор goto (отсутствует), использование functions и exceptions.
Косвенное выполнение кода. Вызов функций через ссылки, использование словарей для управления потоком.
Индексы элементов последовательностей. Работа со списками (list), строками (str), кортежами (tuple).
Инициализация и описание списков, кортежей. Литералы, генераторы списков.
Одномерные массивы (списки). Поиск максимума (max()), минимума (min()), суммы (sum()).
Алгоритмы сортировки в Python. Использование встроенной функции sorted() и метода list.sort(), реализация пузырьковой сортировки для обучения.
Фильтрация последовательностей. Использование списковых включений (list comprehensions) и функции filter().
Двумерные массивы (списки списков). Создание, инициализация, вывод в виде матрицы.
Работа с адресами объектов и таблицами подстановки. Функция id() и использование словарей (dict) для подстановки.
Циклы в Python. Циклы while и for, реализация циклов с постусловием.
Управление циклами. Использование break и continue для прерывания циклов по условию.
Создание составных типов данных. Использование классов (class) и именованных кортежей (namedtuple).
Экземпляры классов. Создание объектов (экземпляров) класса.
Доступ к атрибутам объектов. Точечная нотация (например, obj.attribute).
Битовые операции в Python. Операторы &, |, ^, ~, <<, >>.

2 блок
Битовые сдвиги в Python. Операторы << (сдвиг влево), >> (сдвиг вправо).
Логические (беззнаковые) сдвиги. Особенности реализации сдвигов в Python.
Арифметические (знаковые) сдвиги. Особенности реализации сдвигов в Python.
Циклические сдвиги. Реализация с помощью комбинации битовых операций.
Упаковка данных. Модули struct и array для работы с бинарными данными.
Представление множеств на низком уровне. Использование битовых масок и тип данных set в Python.
Операции над множествами. Использование встроенного типа set и его методов (union, intersection, difference).
Организация кода: модули и функции. Создание функций и модулей для структурирования программы.
Вызов функций в Python. Оператор вызова ().
Операции над множествами. (Повторение, дубликат из 2.7) Использование встроенного типа set.
Организация кода: модули и функции. (Повторение, дубликат из 2.8) Создание функций и модулей.
Вызов функций в Python. (Повторение, дубликат из 2.9) Оператор вызова ().
Возврат из функции. Оператор return.
Передача параметров в функцию. Аргументы функции.
Структура программы с функциями. Формальные и фактические параметры (аргументы).
Способы передачи аргументов. Позиционные и ключевые аргументы.
Передача последовательностей в функцию. Передача списков, кортежей и других итерируемых объектов.
Стек вызовов в Python. Понятие стека вызовов функций, рекурсия.
Работа со стеком. Использование списка (list) как стека с помощью методов append() и pop().
Флаги и состояние программы. Обработка исключений (try...except), проверка условий.
Операции над последовательностями. Встроенные функции (map, filter, zip), методы строк и списков.
Обработка последовательностей. Использование циклов for и генераторов.
Сравнение последовательностей. Операторы сравнения ==, != для списков и строк.
Документирование кода. Строки документирования (docstrings), комментарии, модули like pydoc.

1. lesson1

1.py
"""
int целочисленный 1 234  45352314214
float 1.234 1.2345678901
str "123456789012345678901234567890"
str "text"
str '12-12-2012 Количество кликов: 21'

bool True False

list
set
dict
tuple
frozenset
"""

print(1123)
str1 = '''
длинная 
строка
'''

amount_click = 12
float1 = 1.234
date = '12-12-2012'
register_date = '12-12-2012'

print(type(date))
print(type(amount_click).__name__)
print(type(register_date).__name__)

flag = True
flag2 = False

1. lesson2

1.py
in архис l2

1. lesson3

1.py
"""
len() - количество элементов в последовательности
in - оператор вхождения
"""

for i in range(10):
    print(i)

if 10 in [1, 2, 3, 4, 5]:
    print(True)
else:
    print(False)

print()

forbidden_symbols = ["!", "@", "#", "$", "%", "^", "&", "*", "(", ")"]
login = "aoknfgG98yoi*&"
for letter in login:
    if letter in forbidden_symbols:
        print(letter)

print()

print(len(range(5)))
print(len("  "))
print(len([1, 2, 3, 4, 5]))

1. lesson4

strs.py
someStr = '123z121saf253'
length1 = len([1, 2, 3])
length2 = len(someStr)

sorted1 = sorted(someStr)
print(sorted1)
print(''.join(sorted1))
msg = ' 3 4 456  456456    6 5'
print(msg.split())
print(msg.strip())

# 0x00 - 0
#someStr.replace()

msg = 'qakhbqvbhf'
msg_encoded = msg.encode('utf-8')
msg_decoded = msg_encoded.decode('utf-8')

print(msg_encoded)
print(msg_decoded)

print(type(1))

print(id(msg))

msg.capitalize()  # перевод первого сивола строки в верхний регистр
print(msg)
print(msg.capitalize())
msg = 'qakhbqvbhf'
msg = 'Qakhbqvbhf'
msg.upper() # все в верхний регистр
msg = 'все заглавные'

print(msg.upper())
msg.lower()  # все в нижний регистр
print(msg.upper().lower())

new_msg = msg.upper()
print(new_msg)

msg = 'rt  rttt rttrrtrt куаукаук уккуак укукаку'

print(msg.title()) # первые буквы слов в верхний регистр

print(msg.swapcase()) # меняет в обе стороны

print(msg.count('r', 5, 10))
#считает количество вхождений подстроки
print(msg.find('r', 5, 10)) # возвращает индекс первого вхожденич подстроки
msg = 'rt  rttt rttrrtrt куаукаук уккуак укукаку'
msg = 'rt  rttt Rttrrtrt куаукаук уTкуак укукаку'
#print(msg.index('r', 5, 10))
# аналогично .fing, но возвращает ValueError, если подстроки нет
print(msg.rindex('r', 2, 20)) # r - с конца
print(msg.rfind('к', 2, 20)) # r - с конца

#проверка конца и начала
print(msg.startswith('rt  '))
print(msg.endswith('аку'))

#проверка строк"""
msg = 'Rt  rttt rttrrtrt куаукаук уккуак укукаку'

print(msg.isupper()) # все ли из заглавных
print(msg.islower()) # все ли из строчных
print(msg.isalnum()) # все ли из букв и цифр
print(msg.isalpha()) # все ли из букв
print(msg.isdigit()) # все ли из цифр
print(msg.isspace()) # все ли из пробелов ("" "\n" "\t")
print("Msg Rt".istitle()) # первая - заглавная

#форматирование

print(msg.center(len(msg) + 11, '*')) #дополняет символами слева и справа
print(msg.ljust(len(msg) + 11))
print(msg.rjust(len(msg) + 11, '*'))
msg = '123'
print(msg.zfill(9))
msg = '+123'
print(msg.zfill(9))
msg = '-0.123'
print(msg.zfill(9))

print('frffr', 'ererferfer', 'erfr', sep='\n')
print('frffr', 'ererferfer', 'erfr', sep='\t')
print('frffr', 'ererferfer', 'erfr', sep=' ')
print('frffr', 'ererferfer', 'erfr', sep='??')
print('frffr', 'ererferfer', 'erfr', end='\n')
print('frffr', 'ererferfer', 'erfr', end='\t')
print('frffr', 'ererferfer', 'erfr', end=' ')
print('frffr', 'ererferfer', 'erfr', end='??')

msg = 'Rt  rttt rttrrtrt куаукаук уккуак укукаку'
"""
:b - двоичная форма
:с - преобразование в юникод
:d - десятичный
:о - восьмеричный
:х - шеснадцатеричный, нижний
:+ - отображает + только для положительных
:- - отображает - только для отрицательных
:(пробел) - дополнительный пробел перед положительными и отрицательными
:< - выравнивние по левому краю
:> - по правому краю
:^ - по центру

"""
some_number = 104
print(f'erfger {some_number} = {some_number:b} в двоичной')
print(f'erfger {some_number} = {some_number:b} в двоичной')
print(f'erfger {some_number:c} ')
print(f'erfger {some_number:-} ')
print(f'erfger {some_number:+} ')
print(f'erfger {some_number: } ')
print(f'erfger {some_number:^} ')
print(f'erfger {some_number:<} ')
print(f'erfger {some_number:>} ')
print(f'erfger {some_number:.2f} ') #округление до двух знаков

1. lesson5

func copy.py
"""def add(a: int, b: int) -> int:
    return a + b

def print_sum(a, b):
    print(a + b)

def some_func2():
    print("some")

def many_returns():
    return 1, 2, 3, 4, 5

print(add(1, 2))
print_sum(1, 2)

a, b, c, d, e = many_returns()
print(a, b, c, d, e)



def some_func():
    pass


a = input()
print(a)

def add(a=0, b=0):
    print(a + b)

add(b=5)"""

"""
рекурсия - функция вызывает саму себя
базовый случай - условие прекращения вызовов
"""
# прямая - f вызывает саму себя
# косвенная - f вызывает другую функцию, которая затем вызывает первую
# линейная - f вызывает себя один раз при вычислении результата
# каскадная - f вызывает себя несколько раз

# каскадная - f вызывает себя несколько раз
"""def fibonacci(n):
    if n <= 2:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)"""


# n!
# прямая - f вызывает саму себя
# линейная - f вызывает себя один раз при вычислении результата
#abs - модуль числа
"""def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)"""
#              5 * f(5 - 1) = 4 * f(4 - 1) = 3
#               5 *         4       *       3
#5*4*3*2 factorial(2 - 1) =1
#5*4*3*2*1
"""n = 5
result = factorial(n)
print(result)
"""
# линейная - f вызывает себя один раз при вычислении результата

"""def collatz(n):
    if n == 1:
        return True
    if n % 2 == 0:
        return collatz(n // 2)
    return collatz(n * 3 + 1)

def nod(a, b):
    if b == 0:
        return a
    if a < b:
        return nod(b, a)
    return nod(b, a % b)
"""
"""
принимает целое число n и выводит все целые от n до 1 включительно
"""
#базовый случай - если n = 1, то функция просто выводит 1 и завершает работу(рекурсию)
#рекурсивный случай - если n > 1,

"""def print_numbers(n):
    if n == 1:
        print(n)
    else:
        print(n)
        print_numbers(n - 1)

n = 5
print_numbers(n)"""
"""
есть набор чисел
[1, 2, 3]
вывести все возможные комбинации чисел
[2, 1, 3]
[3, 2, 1]

написать рек. f, генерирует и выводит комбинации

Простые задачи:
Выбор каждого числа из набора 
и рекурсивная генерация комбинаций оставшихся чисел 
"""
"""def generate_combinations(nums, current_combination=[]):
    # базовый случай: если набор чисел пустой, выводим текущую комбинацию
    if not nums:
        print(current_combination)
    else:
    # рекурсивный:
        for i in range(len(nums)):
            # создаем новый набор без текущего числа
            new_nums = nums[:i] + nums[i + 1:]
            # добавлять текущее число в комбинацию и рекурсивно генерируем комбинацию
            generate_combinations(new_nums, current_combination + [nums[i]])"""

"""for i, num in enumerate(nums):
            # создаем новый набор без текущего числа
            new_nums = nums[:i] + nums[i + 1:]
            # добавлять текущее число в комбинацию и рекурсивно генерируем комбинацию
            generate_combinations(new_nums, current_combination + [num])"""

"""numbers = [1, 2, 3]
generate_combinations(numbers)"""
"""count = 0
cache = {}
def fibonacci(n):
    global count
    if n in cache:
        return cache[n]

    if n <= 1:
        count += 1
        result = n
    else:
        result = fibonacci(n - 1) + fibonacci(n - 2)

    cache[n] = result
    return result

n = 15
result = fibonacci(n)
print(result)
print(count)
for key, value in cache.items():
    print(key, value)
"""

"""
def add(a, b):
    return a + b

def curried_add(a):
    def add_b(b):
        return a + b
    return add_b

add_2 = curried_add(2)
print(add_2(3))

curried_add = lambda a : lambda b : a + b
print(curried_add(2)(3))
"""
#map filter reduce (import functools)

"""from functools import partial

def multiply(a, b):
    return a * b

double = partial(multiply, 2)
print(double(5))
print(multiply(2, 5))"""

"""
*args
**kwargs
"""
#*args
#sum()

"""def sum_numbers(a, b, c):
    return a + b + c"""

"""def sum_numbers(*args):
    return sum(args)"""

"""def sum_numbers(*args):
    result = 0
    for e in args:
        result += e
        print(e)
    return result

print(sum_numbers(1, 2, 3, 5))"""

#**kwargs

"""def print_person_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_person_info(name='alice', age=43, city='moscow')

def show_info(*args, **kwargs):
    print("позиционные", args)
    print("именованные", kwargs)

show_info(1, 2, 3, name='alice', age=43)"""


"""
последовательность передачи:

обычные аргументы
*args
обычные именованные аргументы
**kwargs
"""

"""def demo(a, b, *args, c=10, d=20, **kwargs):
    print(a, b, args, c, d, kwargs)"""

"""
распаковка аргументов
*iterable позиционных
**dict именованных
"""
#пример каррирование map filter

"""def sum_numbers(a, b, c):
    return a + b + c

#*iterable
numbers = [1, 2, 3]

sum_numbers(*numbers) # 1, 2, 3 - как отдельные аргументы
#sum_numbers(1, 2, 3)

values = (10, 20, 30)
print(sum_numbers(*values))

nums = {4, 5, 6}
print(sum_numbers(*nums))
#print(sum_numbers(4, 5, 6))
#print(sum_numbers(6, 4, 5))

first, *rest = [1, 2, 3, 4, 5]
print(first)
print(rest)

*head, last = [1, 2, 3, 4, 5]
print(head)
print(last)

#**dict

def person_info(name, age, city):
    print(f"Имя: {name}, Возраст: {age}, Город: {city}")

data = {"name": "alice", "age": 25, "city": 'moscow'}
person_info(**data)
#person_info(name= alice age= 25 city =moscow)

data = {"name": "alice"}
person_info(**data, age=30, city='dwv')

def show_info(**kwargs):
    for key, value in kwargs.items():
        print(key, value)

data = {"name": "alice", "age": 25, "city": 'moscow'}
show_info(**data)

def get_numbers():
    return [1, 2, 3]

a, b, c = get_numbers()
numbers = [10, 20, 30]
print(*numbers, sep='\n')"""

#ошибки
""" 
def greet(name, age):
    print(name, age)
  
data = {"name": "alice"}
greet(**data)

data = {"name": "alice", "age": 25, "city": 'moscow'}
greet(data)"""

#yeild
def my_function():
    return [1, 2, 3]

result = my_function()
print(result)

def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()
print(next(gen))
print(next(gen))
print(next(gen))

def example_generator():
    print('старт генератора')
    yield "first"
    print('пауза')
    yield "second"
    print('остановка')

gen = example_generator()
print(next(gen))
print(next(gen))


def big_list(n):
    return [i for i in range(n)]

data = big_list(100000)

def big_generator(n):
    for i in range(n):
        yield i

data2 = big_generator(100000)

def infinite_counter():
    num = 1
    while True:
        yield num
        num += 1

gen = infinite_counter()

print(next(gen))
print(next(gen))
print(next(gen))
print(next(gen))
print(next(gen))
print(next(gen))
print(next(gen))
print(next(gen))
print(next(gen))
print(next(gen))

def read_file(filename):
    with open(filename, 'r') as file:
        for line in file:
            yield line.strip()

"""for line in read_file('large_file.txt'):
    print(line)"""

def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib = fibonacci()

print(next(fib))
print(next(fib))
print(next(fib))
print(next(fib))
print(next(fib))
print(next(fib))
print(next(fib))
print(next(fib))
print(next(fib))


#next(generator) - получение следующего значения
#generator.send(value) - отправить значение в генератор
#generator.close() - остановить генератор

def greeter():
    name = yield "как тебя зовут?"
    yield f"hi, {name}"

gen = greeter()
print(next(gen))
print(gen.send("me"))

def counter():
    num = 0
    while True:
        step = yield num
        num += step if step else 1

gen = counter()

print(next(gen))
print(gen.send(5))
print(gen.send(2))
print(next(gen))

def calculator():
    result = 0
    try:
        while True:
            operation = yield result
            if operation:
                op, num = operation
                if op == "+":
                    result += num
    except GeneratorExit:
        print("закрыт")

gen = calculator()
print(next(gen))
print(gen.send(('+', 10)))
print(gen.send(('+', 10)))
gen.close()

#iter(obj) - превращает iterable в iterator

numbers = [1, 2, 3]
iterator = iter(numbers)

print(next(iterator))
print(next(iterator))
print(next(iterator))


"""
iterable - итерируемый объект - list tiple dict set str frozenset
iterator - итератор - obj, помнит где он находится в последовательности, __iter__() __next__()
"""

numbers = [1, 2, 3]
for num in numbers:
    print(num)

for num in numbers:
    print(num)

for num in numbers:
    print(num)

iterator = iter([1, 2, 3])
print(next(iterator))
print(next(iterator))
print(next(iterator))

for num in [1, 2, 3]:
    print(num)

"""
1 iter([1, 2, 3]) создается итератор
2 next() на каждом шаге цикла
3 StopIteration завершается
"""

class Counter:
    def __init__(self):
        self.num = 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.num > 3:
            raise StopIteration
        value = self.num
        self.num += 1
        return value

counter = Counter()
for num in counter:
    print(num)

import sys
print('вводите до стоп')
for line in iter(sys.stdin.readline, 'стоп\n'):
    print(f'введено {line.strip()}')

#iter(func, sentinel)

func.py
def minimum_function():
    pass

def minimum_function2():
    ...

def add(a, b):
    g = 9.8
    print(a + b)
    print(a + b)
    print(g)
    print(id(a))
    print(id(b))
    print()

    
def custom_print():
    print("Hello world")
    print("Hello world")
    print("Hello world")

a = 1
b = 2
print(id(a))
print(id(b))

add(a=a, b=b)
add(2, 5)
add(2, 5)
add(2, 5)

print(2, 3)
print(id(a))
print(id(b))
custom_print()

#print(g)

def summa(a, b=0, c=0, d=0):
    print(a + b + c + d)

summa(a=1)
summa(1, 2)
summa(1, 2, 3)

a = int(1.2)
a = summa(1)

print()

def add(a, b):
    return a + b

result = add(1, 2)
print(add(1, 2))


def return_function():
    return {'some': 'data'}

print(return_function())

a: int = 1
a = '1'

def output_data(data):
    print(data)

def output_data(data: str) -> None | int:
    print(data)

def multi_return() -> tuple:
    return 1, "1"

a, b = multi_return()

print(multi_return())
print(a)
print(b)

linkedList1.py
"""1 -> 2 -> 3 -> 4 -> None
1 -> None
 2 -> 3 -> 4 -> None
None <- 4 <-> 5 <-> 6 -> None"""
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def add_to_head(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node

    def add_to_tail(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node

    def remove_from_tail(self):
        if not self.tail:
            return
        if self.head == self.tail:
            self.head = None
            self.tail = None
        else:
            self.tail = self.tail.prev
            self.tail.next = None

    def remove_from_head(self):
        if self.head:
            self.head = self.head.next

    def remove_by_value(self, data):
        if not self.head:
            return
        if self.head.data == data:
            self.remove_from_head()
            return
        if self.tail.data == data:
            self.remove_from_tail()
            return
        current = self.head
        while current.next:
            if current.next.data == data:
                current.next = current.next.next
                return
            current = current.next

    def insert_after(self, target_data, new_data):
        current = self.head
        while current:
            if current.data == target_data:
                new_node = Node(new_data)
                new_node.next = current.next
                new_node.prev = current
                if current.next:
                    current.next.prev = new_node
                else:
                    self.tail = new_node
                current.next = new_node
                return
            current = current.next
        raise ValueError(f"Элемент {target_data} не найден в списке")

    def reverse(self):
        current = self.head
        while current:
            current.next, current.prev = current.prev, current.next
            current = current.prev
        self.head, self.tail = self.tail, self.head

    def clear(self):
        self.head = None

    def remove_at_index(self, index):
        if index < 0:
            raise IndexError("Index cannot be negative")
        if index == 0:
            self.remove_from_head()
            return
        current = self.head
        for _ in range(index - 1):
            if not current:
                raise IndexError("Index out of range")
            current = current.next
        if current and current.next:
            current.next = current.next.next
        else:
            raise IndexError("Index out of range")

    def __str__(self):
        return " <-> ".join(str(item) for item in self) + " -> None"

    def __len__(self):
        return sum(1 for _ in self)

    def __getitem__(self, index):
        if index < 0:
            raise IndexError("Index cannot be negative")
        for i, item in enumerate(self):
            if i == index:
                return item
        raise IndexError("Index out of range")

    def __contains__(self, data):
        return any(item == data for item in self)

    def __iter__(self):
        current = self.head
        while current:
            yield current.data
            current = current.next

    def __add__(self, other):
        new_list = LinkedList()
        for item in self:
            new_list.add_to_tail(item)
        for item in other:
            new_list.add_to_tail(item)
        return new_list

    def __eq__(self, other):
        return len(self) == len(other) and all(a == b for a, b in zip(self, other))

    def __bool__(self):
        return self.head is not None

    def bubble_sort(self):
        if not self.head or not self.head.next:
            return

        swapped = True
        while swapped:
            swapped = False
            current = self.head
            while current.next:
                if current.data > current.next.data:
                    current.data, current.next.data = current.next.data, current.data
                    swapped = True
                current = current.next

    def insertion_sort(self):
        if not self.head or not self.head.next:
            return

        sorted_head = None
        current = self.head

        while current:
            next_node = current.next
            if not sorted_head or sorted_head.data >= current.data:
                current.next = sorted_head
                if sorted_head:
                    sorted_head.prev = current
                sorted_head = current
                sorted_head.prev = None
            else:
                temp = sorted_head
                while temp.next and temp.next.data < current.data:
                    temp = temp.next
                current.next = temp.next
                if temp.next:
                    temp.next.prev = current
                temp.next = current
                current.prev = temp

            current = next_node

        self.head = sorted_head
        self.tail = sorted_head
        while self.tail and self.tail.next:
            self.tail = self.tail.next

    def merge_sort(self):
        if not self.head or not self.head.next:
            return

        def split(head):
            if not head or not head.next:
                return head, None
            slow, fast = head, head
            while fast.next and fast.next.next:
                slow = slow.next
                fast = fast.next.next

            middle = slow
            second_half = middle.next
            middle.next = None

            if second_half:
                second_half.prev = None

            return head, second_half

        def merge(left, right):
            if not left: return right
            if not right: return left
            dummy = Node(0)
            current = dummy

            while left and right:
                if left.data < right.data:
                    current.next, left.prev, left = left, current, left.next
                else:
                    current.next, right.prev, right = right, current, right.next
                current = current.next

                if left:
                    current.next, left.prev = left, current
                elif right:
                    current.next, right.prev = right, current

                head = dummy.next
                head.prev = None
                return head

        def merge_sort_recursive(node):
            if not node or not node.next:
                return node
            left, right = split(node)
            left = merge_sort_recursive(left)
            right = merge_sort_recursive(right)

            return merge(left, right)

        self.head = merge_sort_recursive(self.head)

        current = self.head
        while current.next:
            current = current.next
        self.tail = current


    def binary_search(self, target):
        if not self.head:
            return None

        length = len(self)
        left = self.head
        right = self.tail

        while left != right:
            mid = left
            steps = (length // 2) - 1
            for _ in range(steps):
                mid = mid.next

            if mid.data == target:
                return mid
            elif mid.data < target:
                left = mid.next
            else:
                right = mid.prev

            length = length // 2

        return None

ll1 = LinkedList()
ll1.add_to_tail(30)
ll1.add_to_tail(20)
ll1.add_to_tail(10)
ll1.merge_sort()
print(ll1)

"""ll1 = LinkedList()
ll1.add_to_tail(10)
ll1.add_to_tail(20)
ll1.add_to_tail(30)

ll2 = LinkedList()
ll2.add_to_tail(40)
ll2.add_to_tail(50)

print("Список 1:", ll1)
print("Длина списка 1:", len(ll1))
print("Элемент с индексом 1:", ll1[1])
print("Есть ли 20 в списке 1?", 20 in ll1)

print("Итерация по списку 1:")
for item in ll1:
    print(item, end=" ")
print()

ll3 = ll1 + ll2
print("Объединенный список:", ll3)

print("Списки 1 и 2 равны?", ll1 == ll2)
print("Список 1 пуст?", not ll1)

ll1.clear()
print("Список 1 после очистки:", ll1)
print("Список 1 пуст?", not ll1)"""

myDeque.py
from collections import deque

stack = deque()

stack.append(1)
stack.append(2)
stack.append(3)
print(stack)
print(stack.pop())
print(stack.pop())
print(stack.pop())

if not stack:
    print("Стек пуст")

"""
append(x)     добавляет элемент x в конец стека
pop()         удаляет и возвращает последний элемент стека
if not stack  проверка, пуст ли стек
stack[-1]     Peek Просмотр верхнего элемента
clear()       очистка, не всегда
"""

"""
Дана строка, содержащая скобки различных типов: (), [], {}. 
Необходимо проверить, является ли скобочная последовательность корректной. 
Корректная последовательность означает, 
что каждой открывающей скобке соответствует закрывающая скобка того же типа, 
и скобки правильно вложены друг в друга.
"""

str1 = "()[]{}" # True
str2 = "([{}])" # True
str3 = "(]" # False
str4 = "([)]" # False

def is_valid_brackets(s):
    stack = []
    brackets_map = {')': '(', ']': '[', '}': '{'}
    for char in s:
        if char in brackets_map.values():
            stack.append(char)
        elif char in brackets_map:
            if not stack or stack.pop() != brackets_map[char]:
                return False
    return not stack

print(is_valid_brackets(str1))
print(is_valid_brackets(str2))
print(is_valid_brackets(str3))
print(is_valid_brackets(str4))

queue = deque()

queue.append(1)
queue.append(2)
queue.append(3)
print(queue)

print(queue.popleft())
print(queue.popleft())
print(queue.popleft())
print(queue)

if not queue:
    print("Очередь пуста")

"""
реализовать class структуру данных очередь
добавление элемента в очередь enqueue
удаление элемента из очереди dequeue
получение максимального элемента в очереди get_max max
получение минимального элемента в очереди get_min min

использовать deque 
"""


class SimpleMinMaxQueue:
    def __init__(self):
        self.queue = deque()

    def enqueue(self, x):
        self.queue.append(x)

    def dequeue(self):
        if not self.queue:
            return None
        return self.queue.popleft()

    def get_max(self):
        if not self.queue:
            return None
        return max(self.queue)

    def get_min(self):
        if not self.queue:
            return None
        return min(self.queue)

smq = SimpleMinMaxQueue()
smq.enqueue(3)
smq.enqueue(1)
smq.enqueue(5)
print(smq.get_max())
print(smq.get_min())
print()
smq.dequeue()
print(smq.get_max())
print(smq.get_min())
print()
smq.dequeue()
print(smq.get_max())
print(smq.get_min())
print()
smq.dequeue()
print(smq.get_max())
print(smq.get_min())
"""
добавление
append(x)
appendleft(x)

удаление
pop()
popleft()

методы
clear()  полностью очистить
extend(iterable) — добавляет все элементы из итерируемого объекта в конец deque
extendleft(iterable) — добавляет все элементы из итерируемого объекта в начало deque (элементы добавляются в обратном порядке)
rotate(n) — циклически сдвигает элементы deque на n шагов. Если n положительное, сдвиг происходит вправо, если отрицательное — влево
count(x)  возвращает количество элементов, равных x
remove(x)  удаляет первый найденный элемент, равный x

свойство
maxlen  максимальный размер deque (если задан). Если при добавлении элементов размер превышает maxlen, элементы с противоположного конца автоматически удаляются
"""
d = deque([1, 2, 3])
d.extend([4, 5, 6])  # Добавляем элементы в конец
print(d)  # deque([1, 2, 3, 4, 5, 6])

d = deque([4, 5, 6])
d.extendleft([1, 2, 3])  # Добавляем элементы в начало
print(d)  # deque([3, 2, 1, 4, 5, 6])

d = deque([1, 2, 3, 4, 5])
d.rotate(2)  # Сдвигаем вправо на 2 шага
print(d)  # deque([4, 5, 1, 2, 3])

d.rotate(-2)  # Сдвигаем влево на 2 шага
print(d)  # deque([1, 2, 3, 4, 5])

d = deque([1, 2, 3])
d.clear()  # Очищаем deque
print(d)  # deque([])

d = deque([1, 2, 2, 3, 2, 4])
print(d.count(2))  # 3 (элемент 2 встречается 3 раза)

d = deque([1, 2, 3, 2, 4])
d.remove(2)  # Удаляем первый элемент 2
print(d)  # deque([1, 3, 2, 4])

# Создаем deque с максимальным размером 3
d = deque([1, 2, 3], maxlen=3)
print(d)  # deque([1, 2, 3], maxlen=3)

# Добавляем новый элемент
d.append(4)  # Элемент 1 удаляется, так как maxlen=3
print(d)  # deque([2, 3, 4], maxlen=3)

# Добавляем несколько элементов
d.extend([5, 6])  # Элементы 2 и 3 удаляются
print(d)  # deque([4, 5, 6], maxlen=3)


"""
реализовать скользящее окно для массива чисел. 
для каждого окна размера k найти максимальный элемент."""

nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
"""
[1, 3, -1]  3
[3, -1, -3]  3
[-1, -3, 5]  5
[-3, 5, 3]  5
[5, 3, 6]  6
[3, 6, 7]  7

[3, 3, 5, 5, 6, 7]"""

from collections import deque

def max_in_sliding_window(nums, k):
    if not nums or k == 0:
        return []

    result = []
    d = deque()

    for i, num in enumerate(nums):
        while d and d[0] < i - k + 1:
            d.popleft()

        while d and nums[d[-1]] < num:
            d.pop()

        d.append(i)

        if i >= k - 1:
            result.append(nums[d[0]])

    return result

nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(max_in_sliding_window(nums, k))

sorting.py
"""
бинарный поиск
"""

"""
по способу организации

внутренняя сортировка - в оперативке
внешняя - для больших данных, с записью во временные файлы
"""

"""
по устойчивости (стабильности)

стабильная сортировка- сохраняет порядок одинаковых элементов
нестабильная - может измениться
"""

"""
по принципу работы

обменные алгоритмы - пузырьковая - if else
выборочные - выбором - выбирается минимальный элемент
вставочные - вставками - новый элемент вставляется в отсортированную часть списка
разделяй и властвуй - быстрая, слиянием - рекурсия, части сортируются
"""

"""
.sort() - сортирует список на месте - изменяет его
sorted() - возвращает новый"""

"""numbers = [5, 4, 2, 6, 7, 8, 3, 5, 6, 9]
numbers.sort()
print(numbers)

numbers = [5, 4, 2, 6, 7, 8, 3, 5, 6, 9]
sorted_numbers = sorted(numbers)
print(sorted_numbers)

words = ['123', '1234', '12', '12334']
words.sort(key=len)
print(words)

students = [('иван', 20), ("анна", 18), ("петр", 22)]
students.sort(key=lambda x: x[1])
print(students)

numbers = [5, 4, 2, 6, 7, 8, 3, 5, 6, 9]
numbers.sort(reverse=True)
print(numbers)

numbers = [5, 4, 2, 6, 7, 8, 3, 5, 6, 9]
sorted_numbers = sorted(numbers, reverse=True)
print(sorted_numbers)"""
"""
O(n)
n - размер входных данных (сколько элементов)
"""

"""
простые O(n^2)
пузырьковая, вставками, выбором
"""

"""
продвинутые O(n log n)
слиянием быстрая 
"""

"""
гибридные
timsort: вставками + слиянием
"""

"""
пузырьковая (bubble sort)
"""

"""
1 проход

[5, 3, 8, 4, 2] 5 3 8 4 2
5 > 3
3 5
[3, 5, 8, 4, 2]
5 < 8
[3, 5, 8, 4, 2]
8 > 4
4 8
[3, 5, 4, 8, 2]
8 > 2
2 8
[3, 5, 4, 2, 8]
"""

def bubble_sort_bad(arr):
    for i in range(len(arr)):
        for j in range(len(arr)):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

#[3, 2, 4, 5, 8]
#[2, 3, 4, 5, 8]
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        swapped = False
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break

#выбором (selection sort)

"""
min из неотсортированной части массива
меняем этот минимальный e с первым e неотсортированной части
повторяем
"""

"""
1 проход

[5, 3, 8, 4, 2]
2 <-> 5
[2, 3, 8, 4, 5]

2 проход

[2, 3, 8, 4, 5]
3 <-> 5
[2, 3, 8, 4, 5]

3 проход

[2, 3, 8, 4, 5]
4 <-> 8
[2, 3, 4, 8, 5]

"""

def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        min_index = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index] ,arr[i]

"""numbers = [5, 3, 8, 4, 2]
selection_sort(numbers)
print(numbers)"""

def selection_sort(arr):
    n = len(arr)
    left, right = 0, n - 1
    while left < right:
        min_index = left
        max_index = right

        for i in range(left, right + 1):
            if arr[i] < arr[min_index]:
                min_index = i
            if arr[i] > arr[min_index]:
                max_index = i

        arr[left], arr[min_index] = arr[min_index], arr[left]

        if max_index == left:
            max_index = min_index

        arr[right], arr[max_index] = arr[max_index], arr[right]

        left += 1
        right -= 1
"""
[]
[4, 2, 5, 1]
min 1
[1, 2, 5, 4]
[1]

[1]
[1, 2, 5, 4]
min 2
[1, 2, 5, 4]
[1, 2]

[1, 2]
[1, 2, 5, 4]
min 4
[1, 2, 4, 5]

"""





"""
левая уже отсортирована
правая нет

[5, 2, 4, 6, 1, 3]
2 < 5
[2, 5, 4, 6, 1, 3]
"""

def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1

        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1

        arr[j + 1] = key



"""
[4, 3, 2, 1]
3 4
3 
[3 4 2 1]
2 < 4 
4
[3 4 4 1]
2 < 3
[3 3 4 1]
[2 3 4 1]

[2 3 4 4]
[2 3 3 4]
[2 2 3 4]
[1 2 3 4]
"""

"""
1: выбираем шаг
2: сортируем с шагом
3: уменьшаем шаг
4: дойдя до 1 = обычная вставками

[5, 2, 9, 1, 5, 6]
первые элементы:
i = 0 3 6
[5, 1]
вторые элементы:
i = 1, 4
[2, 5]
третьи элементы:
i = 2, 5
[9, 6]

[1, 2, 6, 5, 5, 9]

хиббарда
"""

def shell_sort(arr):
    n = len(arr)
    gap = n // 2

    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i

            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp

        gap //= 2

# массивы из numpy (они там на C)
"""
массив из 1 элемента - отсортирован
разделяем массив на две части
рекурсивно сортируем каждую из этих частей
сливаем в один массив

[1, 4, 6]
[2, 3, 5]

[8, 4, 5, 7, 1, 3, 6, 2]
[8, 4, 5, 7] [1, 3, 6, 2]
[8, 4] [5, 7] [1, 3] [6, 2]
[8] [4] [5] [7] [1] [3] [6] [2]
[8] [4] -> [4, 8]
[5] [7] -> [5, 7]
[4, 5, 7, 8]
[1, 2, 3, 6]

особенности/важно
стабилен
неинтерактивность
рекурсивность 
"""

def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

        result.extend(left[i:])
        result.extend(right[j:])

        return result

"""

max-heap: каждый родитель больше или равен своим детям
min-heap: каждый родитель меньше или равен своим детям
"""
"""
heap - вид бинарного дерева, частично упорядочена
max-heap (макси-куча): каждый родитель больше или равен своим детям (потомкам)
min-heap (мини-куча): каждый родитель меньше или равен своим детям (потомкам)

max-heap (макси-куча): на вершине максимальный элемент. Получаем минимальный элемент на O(1)
min-heap (мини-куча): на вершине наименьший элемент. Получаем минимальный элемент на O(1)

алгоритм Дейкстры 
heap sort
реализация приоритетной очереди
медиана потока данных
планировщики задач
системы обработки событий
сжатия данных

import heapq - минимальная куча на базе списка
"""
import heapq

numbers = [5, 3, 8, 1, 2]
heapq.heapify(numbers)  # на месте в мин кучу. numbers[0] - минимальный. Порядок остальных не гарантирован
print(numbers)

heapq.heappush(numbers, 0)  # добавляет item в heap и сохраняет ее свойства
print(numbers)

min_element = heapq.heappop(numbers)  # удаляет и возвращает наименьший элемент из кучи
print(min_element)
print(numbers)

#heapq.heappushpop(heap, item) добавляет item, возвращает наименьший элемент

numbers = [5, 3, 8, 1, 2]
#n самых больших или маленьких элементов
print(heapq.nlargest(2, numbers))
print(heapq.nsmallest(3, numbers))


#приоритетная очередь
tasks = []
heapq.heappush(tasks, (2, 'писать отчет'))
heapq.heappush(tasks, (1, 'проверить почту'))
heapq.heappush(tasks, (3, 'созвон с коллегами'))

while tasks:
    task = heapq.heappop(tasks)
    print(f'выполняется задача {task}')

# макси куча

numbers = [5, 3, 8, 1, 2]
max_heap = [-x for x in numbers]
heapq.heapify(max_heap)

max_value = -heapq.heappop(max_heap)
print(max_value)

heap = [1, 3, 5, 7, 9, 8]
"""
        1
      /   \
     3     5
    / \     \
   7   9     8
"""
"""
бинарная куча, каждый узел имеет не более двух детей

"""
"""

для любого элемента с i - индекс
левый потомок на позиции 2*i + 1
правый потомок на позиции 2*i + 2
родитель потомок на позиции (i - 1) // 2

        10              <- индекс 0
      /    \
     9      8           <- индексы 1 и 2
    / \    / \
   7   6  5   4         <- индексы 3,4,5,6
                                arr[3] = 7
                                
arr =[10, 9, 8, 7, 6, 5, 4]
""""""
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)"""

"""
+
экономия памяти
быстрота доступа
простота реализации
универсальность
"""

def build_heap(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

"""
[3, 9, 2, 1, 4, 5]
i = 2 (последний родитель): 2, 5 - переставлять не надо
i = 1: 9, 1, 4 (9 остается на месте)
i = 0: 3, 9, 2 (меняем 3 и 9)
[9, 3, 2, 1, 4, 5]
"""
"""
для любого элемента с i - индекс
левый потомок на позиции 2*i + 1
правый потомок на позиции 2*i + 2
родитель потомок на позиции (i - 1) // 2
i   родитель    левый   правый
0   -   1   2
1   0   3   4
2   0   5   6
3   1   7   8
4   1   9   10

"""
"""
heap sort (по возрастанию) (in-place)
1 массив в максимальную кучу
2 максимальный элемент в корне arr[0]
3 меняем местами с последним элементом в массиве и исключаем из обработки
4 heapify 
5 повторяем

1 построение кучи - проходим по массиву снизу вверх и восстанавливаем кучу от каждого элемента
2 сортировка 
2.1 берем максимум
2.2 меняем с последним неотсортированным элементом
2.3 уменьшаем границу кучи
2.4 heapify

+
O(nlogn)
не требует доп памяти
для больших объемов данных
-
не стабильная (одинаковые элементы могут поменять порядок)
сложная реализация
heapq

[4, 10, 3, 5, 1]
        10
      /    \
    5       3
  /           \
4              1
[1, 5, 3, 4, 10]
[1, 5, 3, 4]
"""

def heapify(arr, n, i, ascending):
    largest_or_smallest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if ascending:
        if left < n and arr[left] > arr[largest_or_smallest]:
            largest_or_smallest = left
        if right < n and arr[right] > arr[largest_or_smallest]:
            largest_or_smallest = right
    else:
        if left < n and arr[left] < arr[largest_or_smallest]:
            largest_or_smallest = left
        if right < n and arr[right] < arr[largest_or_smallest]:
            largest_or_smallest = right

    if largest_or_smallest != i:
        arr[i], arr[largest_or_smallest] = arr[largest_or_smallest], arr[i]
        heapify(arr, n, largest_or_smallest, ascending)


def heap_sort(arr, ascending=True):
    n = len(arr)

    #строим кучу
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i, ascending)

    #сортируем, вытаскивая корень и уменьшая размер кучи
    for i in range(n - 1, 0, -1):

        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0, ascending)
"""
[4, 10, 3, 5, 1]
        10
       /  \
      5    3
     /
    4
[10, 5, 3, 4, 1]
меняем 10 и 1
[1, 5, 3, 4, 10]
heapigy([1, 5, 3, 4]) 
"""

"""
1 выбираем опорный элемент
2 переставляем. Слева все элементы меньше него, справа больше
3 рекурсивно применяем к левому и правому подмассивам
4 1/0 - базовый случай

[5, 3, 8, 4, 2, 7, 1, 7]
5
меньше [3, 4, 2, 1]
больше [8, 7, 6]

первый 
последний
случайный
середина
медиана 
"""
def quick_sort(arr, low, high):
    if low < high:
        pivot_index = partition(arr, low, high)
        quick_sort(arr, low, pivot_index - 1)
        quick_sort(arr, pivot_index + 1, high)

def partition(arr, low, high, ascending=True):
    pivot = arr[high]
    i = low - 1

    for j in range(low, high):
        if (ascending and arr[j] <= pivot) or (not ascending and arr[j] >= pivot):
            i += 1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

"""
вставками, слиянием

run (прогоны) - отсортированная часть
[1, 2, 3, 7, 4, 5, 6, 10]
[1, 2, 3, 7]
[4, 5, 6, 10]

1 нахождение runs
2 вставками
3 слияние runs
4 merge policy условия слияния 
"""
def insertion_sort(arr, left, right):
    for i in range(left + 1, right + 1):
        key = arr[i]
        j = i - 1
        while j >= left and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key


def merge(arr, l, m, r):
    left = arr[l:m+1]
    right = arr[m+1:r+1]
    i = j = 0
    k = l
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1
        k += 1
    while i < len(left):
        arr[k] = left[i]
        i += 1
        k += 1
    while j < len(right):
        arr[k] = right[j]
        j += 1
        k += 1


def timsort(arr):
    n = len(arr)
    RUN = 32  # длина минимального run

    for i in range(0, n, RUN):
        insertion_sort(arr, i, min(i + RUN - 1, n - 1))

    size = RUN
    while size < n:
        for left in range(0, n, 2 * size):
            mid = min(left + size - 1, n - 1)
            right = min(left + 2 * size - 1, n - 1)
            if mid < right:
                merge(arr, left, mid, right)
        size *= 2

theory closure.py
def outer_function(x):
    def inner_function(y):
        return x + y
    return inner_function

closure = outer_function(10)
result = closure(5)
print(result)

# global
global_var = 30
def example():
    global global_var
    global_var += 10
    print(global_var)

example()
print(global_var)

# nonlocal
def outer():
    nonlocal_var = 40

    def inner():
        nonlocal nonlocal_var
        nonlocal_var += 10
        print(nonlocal_var)

    inner()
    print(nonlocal_var)

outer()

def counter():
    count = 0
    def increment():
        nonlocal count
        count += 1
        return count
    return increment

counter1 = counter()
print(counter1())
print(counter1())
print(counter1())

def multiplier(n):
    def multiply(x):
        return  x * n
    return multiply

double = multiplier(2)
triple = multiplier(3)

print(double(5))
print(triple(5))


"""
def возвращает словарь счетчика с методами
+1
-1
текущее
сброс к начальному
история изменений
откат к предыдущему
"""
"""
def smart_counter(initial_value=0):
    value = initial_value
    history_list = [initial_value]

    def increment():
        nonlocal value
        pass

    def decrement():
        nonlocal value
        value -= 1
        history_list.append(value)
    def get_value():
        return value
    def history():
        return history_list
    def undo():
        nonlocal value
        if len(history_list) > 1:
            history_list.pop()
            value = history_list[-1]
    return {
        "increment": increment,
        "decrement": decrement,
        "get_value": get_value,
        #reset
        "history": history,
        "undo": undo,
    }

counter = smart_counter(5)
counter['history']()
counter['undo']()
counter['decrement']()
"""
"""def add(a, b):
    return a + b

def add_curried(a):
    def inner(b):
        def inner2(c):
            return a + b + c
        return inner2
    return inner

result = add_curried(2)(3)(4)
print(result)

from functools import partial
add_two = partial(add, 2)
result = add_two(3)
print(result)

def curry(func):
    def curried(*args):
        if len(args) >= func.__code__.co_argcount:
            return func(*args)
        return lambda *more_args: curried(*(args + more_args))
    return curried

@curry
def add(a, b, c):
    return a + b + c

result = add(1)(2)(3)
print(result)"""

"""
add
subtract
multiply
divide"""

from functools import partial

"""
def operation(a):
    def inner(b):
        def oper(op):
            try:
                if op == 'add':
                    return a + b
                elif op == "subtract":
                    return a - b
                elif op == "divide":
                    if b == 0:
                        raise ZeroDivisionError('нельзя делеить на 0')
                    return a / b
                elif op == 'multiply':
                    return a * b
                else:
                    raise ValueError('текст который будет напечатан при ошибке')
            except ValueError as e:
                return str(e)
            except ZeroDivisionError as e:
                return str(e)
            except Exception as ex:
                return ex
        return oper
    return inner
"""
"""result = operation(10)(5)('add')
print(result)
result = operation(10)(0)('divide')
print(result)
print(result is None)
result = operation(10)(5)('adde')
print(result)
print(result is None)"""

def operation(a, b, operation):
    try:
        if operation == 'add':
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "divide":
            if b == 0:
                raise ZeroDivisionError('123')
            return a / b
        elif operation == 'multiply':
            return a * b
        else:
            raise ValueError('1234')
    except ValueError as e:
        return str(e)
    except ZeroDivisionError as e:
        return str(e)
    except Exception as ex:
        return ex

add = partial(operation, op='add')
my_add = partial(operation, op='add', a=10)
add_10 = partial(partial(operation, a=10), op='add')
divide = partial(operation, op='divide')
divide2 = partial(operation, op='d3ivide')
"""print(add(10, 2))
print(add_10(b=2))
print(divide(10, 2))
print(divide(10, 0))
print(divide2(10, 2))
"""
print(add_10(b=5))
print(my_add(b=5))

1. lesson6

funcs.py
"""
help
len
max
min
sum
sorted
enumerate
zip
abs
round
isinstance
id
all
any
pow
hash
bin
oct
hex

int
"""

my_list = [1, 2, 3, 4, 5]
print(len(my_list))
print(max(my_list))
print(min(my_list))
print(sum(my_list))
print(sorted(my_list, reverse=True))

for index, value in enumerate(my_list):
    print(f"индекс {index} значение {value}")

names = ["ivan", "petr", "anna"]
ages = [20, 22, 18]
cities = ["moscow", "spb", "kazan"]

for name, age, city in zip(names, ages, cities):
    print(f"имя {name} возраст {age} город {city}")

zipped = zip(names, ages, cities)
print(list(zipped))

print(abs(-100))
print(round(6.567, 2))

print(isinstance(100, int))

print(id(my_list))

help(len)

print(any([False, '', [], 1]))
print(all([False, '', [], 1]))

print(pow(2, 3))

1.2. calculator

calculator.py
"""
Модуль calculator.py - Математическое ядро
Содержит все математические операции: базовые арифметические и научные функции.
"""

import math


class CalculatorError(Exception):
    """Базовый класс для ошибок калькулятора"""
    pass


class DivisionByZeroError(CalculatorError):
    """Исключение для деления на ноль"""
    pass


class InvalidInputError(CalculatorError):
    """Исключение для некорректных входных данных"""
    pass


# Базовые арифметические операции
def add(a, b):
    """Сложение двух чисел"""
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise InvalidInputError("Аргументы должны быть числами")
    return a + b


def subtract(a, b):
    """Вычитание двух чисел"""
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise InvalidInputError("Аргументы должны быть числами")
    return a - b


def multiply(a, b):
    """Умножение двух чисел"""
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise InvalidInputError("Аргументы должны быть числами")
    return a * b


def divide(a, b):
    """Деление двух чисел с проверкой деления на ноль"""
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise InvalidInputError("Аргументы должны быть числами")
    if b == 0:
        raise DivisionByZeroError("Деление на ноль невозможно")
    return a / b


# Научные операции
def power(base, exponent):
    """Возведение в степень"""
    if not isinstance(base, (int, float)) or not isinstance(exponent, (int, float)):
        raise InvalidInputError("Аргументы должны быть числами")
    try:
        return math.pow(base, exponent)
    except (OverflowError, ValueError) as e:
        raise CalculatorError(f"Ошибка при возведении в степень: {e}")


def square_root(x):
    """Квадратный корень с проверкой отрицательного значения"""
    if not isinstance(x, (int, float)):
        raise InvalidInputError("Аргумент должен быть числом")
    if x < 0:
        raise InvalidInputError("Нельзя извлечь квадратный корень из отрицательного числа")
    return math.sqrt(x)


def natural_log(x):
    """Натуральный логарифм"""
    if not isinstance(x, (int, float)):
        raise InvalidInputError("Аргумент должен быть числом")
    if x <= 0:
        raise InvalidInputError("Логарифм определен только для положительных чисел")
    return math.log(x)


def logarithm(x, base):
    """Логарифм по произвольному основанию"""
    if not isinstance(x, (int, float)) or not isinstance(base, (int, float)):
        raise InvalidInputError("Аргументы должны быть числами")
    if x <= 0:
        raise InvalidInputError("Логарифм определен только для положительных чисел")
    if base <= 0 or base == 1:
        raise InvalidInputError("Основание логарифма должно быть положительным и не равным 1")
    return math.log(x, base)


def sine(x):
    """Синус угла в радианах"""
    if not isinstance(x, (int, float)):
        raise InvalidInputError("Аргумент должен быть числом")
    return math.sin(x)


def cosine(x):
    """Косинус угла в радианах"""
    if not isinstance(x, (int, float)):
        raise InvalidInputError("Аргумент должен быть числом")
    return math.cos(x)


def tangent(x):
    """Тангенс угла в радианах"""
    if not isinstance(x, (int, float)):
        raise InvalidInputError("Аргумент должен быть числом")
    return math.tan(x)


def factorial(n):
    """Факториал числа с проверкой на неотрицательное целое число"""
    if not isinstance(n, int):
        raise InvalidInputError("Факториал определен только для целых чисел")
    if n < 0:
        raise InvalidInputError("Факториал определен только для неотрицательных чисел")
    return math.factorial(n)

main.py
"""
Модуль main.py - Основная программа с GUI
Реализует интерфейс научного калькулятора используя tkinter.
"""

import tkinter as tk
from tkinter import ttk, messagebox
import math

# Импорт модулей (в реальном проекте это будут отдельные файлы)
# from calculator import *
# from utils import *

# Для демонстрации включаем код модулей здесь
# === Код модуля calculator.py ===
class CalculatorError(Exception):
    """Базовый класс для ошибок калькулятора"""
    pass

class DivisionByZeroError(CalculatorError):
    """Исключение для деления на ноль"""
    pass

class InvalidInputError(CalculatorError):
    """Исключение для некорректных входных данных"""
    pass

def add(a, b):
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise InvalidInputError("Аргументы должны быть числами")
    return a + b

def subtract(a, b):
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise InvalidInputError("Аргументы должны быть числами")
    return a - b

def multiply(a, b):
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise InvalidInputError("Аргументы должны быть числами")
    return a * b

def divide(a, b):
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise InvalidInputError("Аргументы должны быть числами")
    if b == 0:
        raise DivisionByZeroError("Деление на ноль невозможно")
    return a / b

def power(base, exponent):
    if not isinstance(base, (int, float)) or not isinstance(exponent, (int, float)):
        raise InvalidInputError("Аргументы должны быть числами")
    try:
        return math.pow(base, exponent)
    except (OverflowError, ValueError) as e:
        raise CalculatorError(f"Ошибка при возведении в степень: {e}")

def square_root(x):
    if not isinstance(x, (int, float)):
        raise InvalidInputError("Аргумент должен быть числом")
    if x < 0:
        raise InvalidInputError("Нельзя извлечь квадратный корень из отрицательного числа")
    return math.sqrt(x)

def natural_log(x):
    if not isinstance(x, (int, float)):
        raise InvalidInputError("Аргумент должен быть числом")
    if x <= 0:
        raise InvalidInputError("Логарифм определен только для положительных чисел")
    return math.log(x)

def logarithm(x, base):
    if not isinstance(x, (int, float)) or not isinstance(base, (int, float)):
        raise InvalidInputError("Аргументы должны быть числами")
    if x <= 0:
        raise InvalidInputError("Логарифм определен только для положительных чисел")
    if base <= 0 or base == 1:
        raise InvalidInputError("Основание логарифма должно быть положительным и не равным 1")
    return math.log(x, base)

def sine(x):
    if not isinstance(x, (int, float)):
        raise InvalidInputError("Аргумент должен быть числом")
    return math.sin(x)

def cosine(x):
    if not isinstance(x, (int, float)):
        raise InvalidInputError("Аргумент должен быть числом")
    return math.cos(x)

def tangent(x):
    if not isinstance(x, (int, float)):
        raise InvalidInputError("Аргумент должен быть числом")
    return math.tan(x)

def factorial(n):
    if not isinstance(n, int):
        raise InvalidInputError("Факториал определен только для целых чисел")
    if n < 0:
        raise InvalidInputError("Факториал определен только для неотрицательных чисел")
    return math.factorial(n)

# === Код модуля utils.py ===
def degrees_to_radians(degrees):
    if not isinstance(degrees, (int, float)):
        raise ValueError("Аргумент должен быть числом")
    return math.radians(degrees)

def radians_to_degrees(radians):
    if not isinstance(radians, (int, float)):
        raise ValueError("Аргумент должен быть числом")
    return math.degrees(radians)

def format_number(number, precision=6):
    if isinstance(number, float):
        formatted = f"{number:.{precision}f}".rstrip('0').rstrip('.')
        return formatted if formatted else '0'
    return str(number)

def is_valid_number(value):
    try:
        float(value)
        return True
    except (ValueError, TypeError):
        return False

def safe_float(value, default=0.0):
    try:
        return float(value)
    except (ValueError, TypeError):
        return default

def truncate_result(result, max_length=15):
    result_str = str(result)
    if len(result_str) > max_length:
        try:
            float_result = float(result)
            if abs(float_result) > 1e10 or (0 < abs(float_result) < 1e-4):
                return f"{float_result:.3e}"
            else:
                return f"{float_result:.6g}"
        except (ValueError, OverflowError):
            return result_str[:max_length] + "..."
    return result_str


class ScientificCalculator:
    def __init__(self, root):
        self.root = root
        self.root.title("Научный калькулятор")
        self.root.geometry("500x600")
        self.root.resizable(False, False)
        
        # Переменная для хранения текущего выражения
        self.current_expression = ""
        self.result_var = tk.StringVar()
        self.expression_var = tk.StringVar()
        
        # Режим углов (градусы/радианы)
        self.angle_mode = tk.StringVar(value="degrees")
        
        self.setup_ui()
        
    def setup_ui(self):
        """Настройка пользовательского интерфейса"""
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Дисплей калькулятора
        self.create_display(main_frame)
        
        # Режим углов
        self.create_angle_mode_selector(main_frame)
        
        # Кнопки калькулятора
        self.create_buttons(main_frame)
        
    def create_display(self, parent):
        """Создание дисплея калькулятора"""
        display_frame = ttk.Frame(parent)
        display_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Поле для отображения выражения
        expression_entry = ttk.Entry(display_frame, textvariable=self.expression_var, 
                                   font=("Arial", 12), state="readonly")
        expression_entry.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        
        # Поле для отображения результата
        result_entry = ttk.Entry(display_frame, textvariable=self.result_var, 
                               font=("Arial", 16, "bold"), state="readonly")
        result_entry.grid(row=1, column=0, sticky=(tk.W, tk.E))
        
        display_frame.columnconfigure(0, weight=1)
        
    def create_angle_mode_selector(self, parent):
        """Создание селектора режима углов"""
        angle_frame = ttk.Frame(parent)
        angle_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        ttk.Label(angle_frame, text="Режим углов:").grid(row=0, column=0, padx=(0, 10))
        
        ttk.Radiobutton(angle_frame, text="Градусы", variable=self.angle_mode, 
                       value="degrees").grid(row=0, column=1, padx=(0, 10))
        ttk.Radiobutton(angle_frame, text="Радианы", variable=self.angle_mode, 
                       value="radians").grid(row=0, column=2)
        
    def create_buttons(self, parent):
        """Создание кнопок калькулятора"""
        buttons_frame = ttk.Frame(parent)
        buttons_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Стиль кнопок
        button_style = {"width": 8, "height": 2, "font": ("Arial", 10)}
        
        # Ряд 1 - Функции очистки и специальные операции
        buttons_row1 = [
            ("C", self.clear_all), ("CE", self.clear_entry), ("⌫", self.backspace), ("±", self.toggle_sign)
        ]
        
        # Ряд 2 - Научные функции 1
        buttons_row2 = [
            ("x²", lambda: self.add_function("square")), ("x³", lambda: self.add_function("cube")), 
            ("xʸ", lambda: self.add_operator("**")), ("√", lambda: self.add_function("sqrt"))
        ]
        
        # Ряд 3 - Научные функции 2  
        buttons_row3 = [
            ("ln", lambda: self.add_function("ln")), ("log", lambda: self.add_function("log")), 
            ("sin", lambda: self.add_function("sin")), ("cos", lambda: self.add_function("cos"))
        ]
        
        # Ряд 4 - Научные функции 3
        buttons_row4 = [
            ("tan", lambda: self.add_function("tan")), ("n!", lambda: self.add_function("factorial")), 
            ("π", lambda: self.add_number(str(math.pi))), ("e", lambda: self.add_number(str(math.e)))
        ]
        
        # Ряд 5 - Числа и операции 1
        buttons_row5 = [
            ("(", lambda: self.add_operator("(")), (")", lambda: self.add_operator(")")), 
            ("/", lambda: self.add_operator("/")), ("*", lambda: self.add_operator("*"))
        ]
        
        # Ряд 6 - Числа 7,8,9 и вычитание
        buttons_row6 = [
            ("7", lambda: self.add_number("7")), ("8", lambda: self.add_number("8")), 
            ("9", lambda: self.add_number("9")), ("-", lambda: self.add_operator("-"))
        ]
        
        # Ряд 7 - Числа 4,5,6 и сложение
        buttons_row7 = [
            ("4", lambda: self.add_number("4")), ("5", lambda: self.add_number("5")), 
            ("6", lambda: self.add_number("6")), ("+", lambda: self.add_operator("+"))
        ]
        
        # Ряд 8 - Числа 1,2,3 и равно
        buttons_row8 = [
            ("1", lambda: self.add_number("1")), ("2", lambda: self.add_number("2")), 
            ("3", lambda: self.add_number("3")), ("=", self.calculate)
        ]
        
        # Ряд 9 - 0, точка и равно
        buttons_row9 = [
            ("0", lambda: self.add_number("0")), (".", lambda: self.add_operator(".")), 
            ("", None), ("=", self.calculate)
        ]
        
        all_buttons = [buttons_row1, buttons_row2, buttons_row3, buttons_row4, 
                      buttons_row5, buttons_row6, buttons_row7, buttons_row8, buttons_row9]
        
        for row_idx, row in enumerate(all_buttons):
            for col_idx, (text, command) in enumerate(row):
                if text and command:
                    if text == "=" and row_idx == 8:
                        btn = tk.Button(buttons_frame, text=text, command=command, **button_style)
                        btn.grid(row=row_idx, column=col_idx, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), padx=1, pady=1)
                    else:
                        btn = tk.Button(buttons_frame, text=text, command=command, **button_style)
                        btn.grid(row=row_idx, column=col_idx, sticky=(tk.W, tk.E, tk.N, tk.S), padx=1, pady=1)
        
        # Настройка весов столбцов и строк
        for i in range(4):
            buttons_frame.columnconfigure(i, weight=1)
        for i in range(9):
            buttons_frame.rowconfigure(i, weight=1)
            
    def add_number(self, number):
        """Добавление числа к выражению"""
        self.current_expression += number
        self.update_display()
        
    def add_operator(self, operator):
        """Добавление оператора к выражению"""
        if operator in ["(", ")"]:
            self.current_expression += operator
        elif operator == ".":
            # Проверяем, что точка не дублируется в текущем числе
            if "." not in self.current_expression.split()[-1] if self.current_expression else True:
                self.current_expression += operator
        else:
            # Добавляем пробелы вокруг операторов для читаемости
            if self.current_expression and not self.current_expression.endswith(" "):
                self.current_expression += " "
            self.current_expression += operator + " "
        self.update_display()
        
    def add_function(self, func_name):
        """Добавление функции к выражению"""
        if func_name in ["square", "cube"]:
            if self.current_expression:
                if func_name == "square":
                    self.current_expression += "**2"
                else:  # cube
                    self.current_expression += "**3"
        else:
            self.current_expression += f"{func_name}("
        self.update_display()
        
    def clear_all(self):
        """Полная очистка"""
        self.current_expression = ""
        self.result_var.set("")
        self.update_display()
        
    def clear_entry(self):
        """Очистка текущего ввода"""
        self.current_expression = ""
        self.update_display()
        
    def backspace(self):
        """Удаление последнего символа"""
        if self.current_expression:
            self.current_expression = self.current_expression[:-1]
            self.update_display()
            
    def toggle_sign(self):
        """Изменение знака числа"""
        if self.current_expression:
            try:
                # Простая реализация: добавляем - в начало или убираем его
                if self.current_expression.startswith("-"):
                    self.current_expression = self.current_expression[1:]
                else:
                    self.current_expression = "-" + self.current_expression
                self.update_display()
            except:
                pass
                
    def update_display(self):
        """Обновление дисплея"""
        self.expression_var.set(self.current_expression)
        
    def calculate(self):
        """Вычисление результата"""
        if not self.current_expression:
            return
            
        try:
            # Подготовка выражения для вычисления
            expression = self.prepare_expression()
            result = eval(expression, self.get_safe_namespace())
            
            # Форматирование результата
            formatted_result = truncate_result(result)
            self.result_var.set(formatted_result)
            
            # Сохраняем результат как новое выражение
            self.current_expression = str(result)
            self.update_display()
            
        except Exception as e:
            error_msg = str(e)
            if isinstance(e, (DivisionByZeroError, InvalidInputError, CalculatorError)):
                error_msg = str(e)
            else:
                error_msg = "Ошибка вычисления"
            
            self.result_var.set(f"Ошибка: {error_msg}")
            messagebox.showerror("Ошибка", error_msg)
            
    def prepare_expression(self):
        """Подготовка выражения для вычисления"""
        expression = self.current_expression
        
        # Замена функций
        replacements = {
            "sqrt(": "square_root(",
            "ln(": "natural_log(",
            "log(": "logarithm(",
            "sin(": f"sine({'degrees_to_radians(' if self.angle_mode.get() == 'degrees' else ''}",
            "cos(": f"cosine({'degrees_to_radians(' if self.angle_mode.get() == 'degrees' else ''}",
            "tan(": f"tangent({'degrees_to_radians(' if self.angle_mode.get() == 'degrees' else ''}",
            "factorial(": "factorial(int("
        }
        
        for old, new in replacements.items():
            expression = expression.replace(old, new)
            
        # Добавляем дополнительные скобки для тригонометрических функций в режиме градусов
        if self.angle_mode.get() == "degrees":
            for func in ["sine", "cosine", "tangent"]:
                if f"{func}(degrees_to_radians(" in expression:
                    # Находим соответствующие скобки и добавляем закрывающую скобку
                    expression = self.fix_trig_brackets(expression, func)
                    
        # Добавляем закрывающую скобку для factorial(int(
        expression = expression.replace("factorial(int(", "factorial(int(") 
        if "factorial(int(" in expression:
            expression = self.fix_factorial_brackets(expression)
            
        return expression
        
    def fix_trig_brackets(self, expression, func_name):
        """Исправление скобок для тригонометрических функций"""
        pattern = f"{func_name}(degrees_to_radians("
        start = 0
        while True:
            pos = expression.find(pattern, start)
            if pos == -1:
                break
                
            # Найти соответствующую закрывающую скобку
            bracket_count = 2  # две открывающие скобки
            i = pos + len(pattern)
            while i < len(expression) and bracket_count > 0:
                if expression[i] == '(':
                    bracket_count += 1
                elif expression[i] == ')':
                    bracket_count -= 1
                i += 1
                
            if bracket_count == 0:
                # Добавить дополнительную закрывающую скобку
                expression = expression[:i] + ')' + expression[i:]
                
            start = pos + 1
            
        return expression
        
    def fix_factorial_brackets(self, expression):
        """Исправление скобок для factorial"""
        pattern = "factorial(int("
        start = 0
        while True:
            pos = expression.find(pattern, start)
            if pos == -1:
                break
                
            # Найти соответствующую закрывающую скобку для int(
            bracket_count = 1
            i = pos + len(pattern)
            while i < len(expression) and bracket_count > 0:
                if expression[i] == '(':
                    bracket_count += 1
                elif expression[i] == ')':
                    bracket_count -= 1
                i += 1
                
            if bracket_count == 0:
                # Добавить дополнительную закрывающую скобку для factorial
                expression = expression[:i] + ')' + expression[i:]
                
            start = pos + 1
            
        return expression
        
    def get_safe_namespace(self):
        """Получение безопасного пространства имен для eval"""
        return {
            # Математические функции из модуля calculator
            'add': add,
            'subtract': subtract,
            'multiply': multiply,
            'divide': divide,
            'power': power,
            'square_root': square_root,
            'natural_log': natural_log,
            'logarithm': logarithm,
            'sine': sine,
            'cosine': cosine,
            'tangent': tangent,
            'factorial': factorial,
            
            # Утилиты из модуля utils
            'degrees_to_radians': degrees_to_radians,
            'radians_to_degrees': radians_to_degrees,
            
            # Математические константы
            'pi': math.pi,
            'e': math.e,
            
            # Встроенные функции Python для математики
            'abs': abs,
            'int': int,
            'float': float,
            'round': round,
            'max': max,
            'min': min,
        }


def run_demo():
    """Демонстрация работы калькулятора с тестовыми сценариями"""
    print("=== ДЕМОНСТРАЦИЯ НАУЧНОГО КАЛЬКУЛЯТОРА ===\n")
    
    # Тестовые сценарии
    test_cases = [
        # Арифметические операции
        ("Арифметические операции", [
            (lambda: add(10, 5), "add(10, 5)"),
            (lambda: subtract(10, 3), "subtract(10, 3)"),
            (lambda: multiply(4, 6), "multiply(4, 6)"),
            (lambda: divide(15, 3), "divide(15, 3)"),
        ]),
        
        # Научные операции
        ("Научные операции", [
            (lambda: power(2, 3), "power(2, 3)"),
            (lambda: square_root(16), "square_root(16)"),
            (lambda: natural_log(math.e), "natural_log(e)"),
            (lambda: logarithm(100, 10), "logarithm(100, 10)"),
            (lambda: factorial(5), "factorial(5)"),
        ]),
        
        # Тригонометрические функции
        ("Тригонометрические функции", [
            (lambda: sine(degrees_to_radians(30)), "sin(30°)"),
            (lambda: cosine(degrees_to_radians(60)), "cos(60°)"),
            (lambda: tangent(degrees_to_radians(45)), "tan(45°)"),
            (lambda: sine(math.pi/2), "sin(π/2)"),
        ]),
        
        # Примеры с ошибками
        ("Обработка ошибок", [
            (lambda: divide(10, 0), "divide(10, 0)"),
            (lambda: square_root(-4), "square_root(-4)"),
            (lambda: natural_log(-5), "natural_log(-5)"),
            (lambda: factorial(-3), "factorial(-3)"),
        ]),
    ]
    
    for section_name, tests in test_cases:
        print(f"--- {section_name} ---")
        for test_func, description in tests:
            try:
                result = test_func()
                formatted_result = truncate_result(result)
                print(f"✓ {description} = {formatted_result}")
            except Exception as e:
                print(f"✗ {description} = ОШИБКА: {e}")
        print()


def main():
    """Главная функция"""
    print("Запуск научного калькулятора...")
    
    # Сначала запускаем демонстрацию
    run_demo()
    
    # Затем запускаем GUI
    root = tk.Tk()
    calculator = ScientificCalculator(root)
    
    # Центрирование окна
    root.update_idletasks()
    x = (root.winfo_screenwidth() // 2) - (root.winfo_width() // 2)
    y = (root.winfo_screenheight() // 2) - (root.winfo_height() // 2)
    root.geometry(f"+{x}+{y}")
    
    root.mainloop()


if __name__ == "__main__":
    main()

utils.py
"""
Модуль utils.py - Вспомогательные утилиты
Содержит функции для преобразования единиц измерения, форматирования вывода
и проверки данных.
"""

import math


# Утилиты преобразования единиц измерения
def degrees_to_radians(degrees):
    """Преобразование градусов в радианы"""
    if not isinstance(degrees, (int, float)):
        raise ValueError("Аргумент должен быть числом")
    return math.radians(degrees)


def radians_to_degrees(radians):
    """Преобразование радианов в градусы"""
    if not isinstance(radians, (int, float)):
        raise ValueError("Аргумент должен быть числом")
    return math.degrees(radians)


# Утилиты форматирования вывода
def format_operation(operation_name, operands, result):
    """Форматирование математических операций для красивого вывода"""
    if isinstance(operands, (list, tuple)):
        operands_str = ", ".join(str(op) for op in operands)
    else:
        operands_str = str(operands)
    
    return f"{operation_name}({operands_str}) = {result}"


def create_result_string(operation, result, error=None):
    """Создание строки с результатом вычисления"""
    if error:
        return f"{operation}: ОШИБКА - {error}"
    else:
        return f"{operation}: {result}"


def format_number(number, precision=6):
    """Форматирование числа с заданной точностью"""
    if isinstance(number, float):
        # Убираем незначащие нули
        formatted = f"{number:.{precision}f}".rstrip('0').rstrip('.')
        return formatted if formatted else '0'
    return str(number)


# Утилиты для работы с данными
def is_integer(value):
    """Проверка числа на целость"""
    if isinstance(value, int):
        return True
    if isinstance(value, float):
        return value.is_integer()
    try:
        float_val = float(value)
        return float_val.is_integer()
    except (ValueError, TypeError):
        return False


def is_positive(value):
    """Проверка числа на положительность"""
    try:
        num_val = float(value)
        return num_val > 0
    except (ValueError, TypeError):
        return False


def is_valid_number(value):
    """Проверка на корректное число"""
    try:
        float(value)
        return True
    except (ValueError, TypeError):
        return False


def safe_float(value, default=0.0):
    """Безопасное преобразование в float"""
    try:
        return float(value)
    except (ValueError, TypeError):
        return default


def truncate_result(result, max_length=15):
    """Усечение результата для отображения в интерфейсе"""
    result_str = str(result)
    if len(result_str) > max_length:
        try:
            # Для очень больших или очень маленьких чисел используем научную нотацию
            float_result = float(result)
            if abs(float_result) > 1e10 or (0 < abs(float_result) < 1e-4):
                return f"{float_result:.3e}"
            else:
                return f"{float_result:.6g}"
        except (ValueError, OverflowError):
            return result_str[:max_length] + "..."
    return result_str

1.2. calculator_min

calculator.py
import math

def add(a, b):
    """Сложение двух чисел"""
    return a + b

def subtract(a, b):
    """Вычитание двух чисел"""
    return a - b

def multiply(a, b):
    """Умножение двух чисел"""
    return a * b

def divide(a, b):
    """Деление двух чисел"""
    if b == 0:
        raise ValueError("Ошибка: деление на ноль невозможно")
    return a / b

def power(base, exponent):
    """Возведение в степень"""
    return math.pow(base, exponent)

def square_root(x):
    """Квадратный корень"""
    if x < 0:
        raise ValueError("Ошибка: нельзя извлечь корень из отрицательного числа")
    return math.sqrt(x)

def natural_logarithm(x):
    """Натуральный логарифм"""
    if x <= 0:
        raise ValueError("Ошибка: логарифм определен только для положительных чисел")
    return math.log(x)

def logarithm(x, base):
    """Логарифм по произвольному основанию"""
    if x <= 0 or base <= 0 or base == 1:
        raise ValueError("Ошибка: некорректные значения для логарифма")
    return math.log(x, base)

def sine(angle_rad):
    """Синус угла в радианах"""
    return math.sin(angle_rad)

def cosine(angle_rad):
    """Косинус угла в радианах"""
    return math.cos(angle_rad)

def tangent(angle_rad):
    """Тангенс угла в радианах"""
    return math.tan(angle_rad)

def factorial(n):
    """Факториал числа"""
    if not isinstance(n, int) or n < 0:
        raise ValueError("Ошибка: факториал определен для неотрицательных целых чисел")
    return math.factorial(n)

main.py
from calculator import *
from utils import *

def demonstrate_arithmetic_operations():
    """Демонстрация арифметических операций"""
    print("=" * 50)
    print("АРИФМЕТИЧЕСКИЕ ОПЕРАЦИИ")
    print("=" * 50)
    
    # Корректные операции
    test_cases = [
        ("+", add, 15, 3),
        ("-", subtract, 15, 3),
        ("×", multiply, 15, 3),
        ("÷", divide, 15, 3)
    ]
    
    for symbol, operation, a, b in test_cases:
        try:
            result = operation(a, b)
            print(format_operation(symbol, (a, b), result))
        except ValueError as e:
            print(f"{a} {symbol} {b} -> {e}")
    
    # Обработка ошибок
    print("\nОбработка ошибок:")
    try:
        divide(10, 0)
    except ValueError as e:
        print(f"10 ÷ 0 -> {e}")

def demonstrate_scientific_operations():
    """Демонстрация научных операций"""
    print("\n" + "=" * 50)
    print("НАУЧНЫЕ ОПЕРАЦИИ")
    print("=" * 50)
    
    # Операции с одним аргументом
    single_arg_operations = [
        ("√", square_root, 25),
        ("ln", natural_logarithm, math.e),
        ("√", square_root, -4),  # Ошибочный случай
        ("ln", natural_logarithm, -1)  # Ошибочный случай
    ]
    
    for symbol, operation, x in single_arg_operations:
        try:
            result = operation(x)
            print(format_operation(symbol, (x,), result))
        except ValueError as e:
            print(f"{symbol}({x}) -> {e}")
    
    # Операции с двумя аргументами
    print("\nОперации с двумя аргументами:")
    try:
        result = power(2, 8)
        print(format_operation("^", (2, 8), result))
    except ValueError as e:
        print(f"2 ^ 8 -> {e}")
    
    try:
        result = logarithm(100, 10)
        print(format_operation("log", (100, 10), result))
    except ValueError as e:
        print(f"log₁₀(100) -> {e}")

def demonstrate_trigonometric_operations():
    """Демонстрация тригонометрических операций"""
    print("\n" + "=" * 50)
    print("ТРИГОНОМЕТРИЧЕСКИЕ ОПЕРАЦИИ")
    print("=" * 50)
    
    angles_degrees = [0, 30, 45, 60, 90]
    angles_radians = [degrees_to_radians(angle) for angle in angles_degrees]
    
    print("Углы в градусах и радианах:")
    for deg, rad in zip(angles_degrees, angles_radians):
        print(f"{deg}° = {rad:.3f} рад")
    
    print("\nТригонометрические функции:")
    for deg, rad in zip(angles_degrees, angles_radians):
        sin_val = sine(rad)
        cos_val = cosine(rad)
        
        print(f"{deg}°: sin = {sin_val:.3f}, cos = {cos_val:.3f}", end="")
        
        try:
            tan_val = tangent(rad)
            print(f", tan = {tan_val:.3f}")
        except ValueError:
            print(f", tan = не определен")

def demonstrate_factorial_operations():
    """Демонстрация операций с факториалом"""
    print("\n" + "=" * 50)
    print("ОПЕРАЦИИ С ФАКТОРИАЛОМ")
    print("=" * 50)
    
    numbers = [0, 1, 5, 10]
    
    for n in numbers:
        try:
            result = factorial(n)
            print(format_operation("!", (n,), result))
        except ValueError as e:
            print(f"{n}! -> {e}")
    
    # Ошибочные случаи
    print("\nОбработка ошибок:")
    error_cases = [-1, 3.5, "5"]
    
    for case in error_cases:
        try:
            result = factorial(case)
            print(format_operation("!", (case,), result))
        except (ValueError, TypeError) as e:
            print(f"{case}! -> {e}")

def demonstrate_utility_functions():
    """Демонстрация вспомогательных функций"""
    print("\n" + "=" * 50)
    print("ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ")
    print("=" * 50)
    
    # Преобразование единиц
    test_degrees = [0, 90, 180, 270, 360]
    print("Преобразование градусов в радианы:")
    for deg in test_degrees:
        rad = degrees_to_radians(deg)
        deg_back = radians_to_degrees(rad)
        print(f"{deg}° = {rad:.3f} рад -> {deg_back:.1f}°")
    
    # Проверка свойств чисел
    print("\nПроверка свойств чисел:")
    test_numbers = [5, -3, 0, 7.0, 8.5]
    for num in test_numbers:
        int_check = "целое" if is_integer(num) else "не целое"
        pos_check = "положительное" if is_positive(num) else "не положительное"
        print(f"{num}: {int_check}, {pos_check}")

def main():
    """Основная функция программы"""
    print("НАУЧНЫЙ КАЛЬКУЛЯТОР")
    print("Демонстрация модульной архитектуры")
    print("=" * 50)
    
    try:
        demonstrate_arithmetic_operations()
        demonstrate_scientific_operations()
        demonstrate_trigonometric_operations()
        demonstrate_factorial_operations()
        demonstrate_utility_functions()
        
        print("\n" + "=" * 50)
        print("ДЕМОНСТРАЦИЯ ЗАВЕРШЕНА УСПЕШНО")
        print("=" * 50)
        
    except Exception as e:
        print(f"\nПроизошла непредвиденная ошибка: {e}")

if __name__ == "__main__":
    main()

utils.py
import math

def degrees_to_radians(degrees):
    """Преобразование градусов в радианы"""
    return degrees * (math.pi / 180.0)

def radians_to_degrees(radians):
    """Преобразование радианов в градусы"""
    return radians * (180.0 / math.pi)

def format_operation(operation_name, operands, result):
    """Форматирование операции для красивого вывода"""
    if len(operands) == 1:
        return f"{operation_name}({operands[0]}) = {result}"
    else:
        return f"{operands[0]} {operation_name} {operands[1]} = {result}"

def format_result(operation, result):
    """Форматирование результата вычисления"""
    return f"Результат: {result}"

def is_integer(number):
    """Проверка, является ли число целым"""
    return isinstance(number, int) or (isinstance(number, float) and number.is_integer())

def is_positive(number):
    """Проверка, является ли число положительным"""
    return number > 0

1. lesson7

3.py


